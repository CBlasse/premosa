#ifdef _MSC_VER

#pragma warning( disable:4996 )

#ifndef __cplusplus
#define inline __inline
#endif

#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>

//  WINDOW pthreads "LIBRARY"

  //  Mutex macros

typedef SRWLOCK pthread_mutex_t;

#define PTHREAD_MUTEX_INITIALIZER RTL_SRWLOCK_INIT

#define pthread_mutex_lock(m)  AcquireSRWLockExclusive(m)

#define pthread_mutex_unlock(m) ReleaseSRWLockExclusive(m)

  //  Condition variable macros

typedef CONDITION_VARIABLE pthread_cond_t;

#define PTHREAD_COND_INITIALIZER RTL_CONDITION_VARIABLE_INIT

#define pthread_cond_signal(c) WakeConditionVariable(c)

#define pthread_cond_broadcast(c) WakeAllConditionVariable(c)

#define pthread_cond_wait(c,m) SleepConditionVariableSRW(c,m,INFINITE,0)

  //  Simple thread support

typedef struct
  { HANDLE *handle;
    void   *(*fct)(void *);
    void   *arg;
    void   *retval;
    int     id;
  } Mythread;

typedef Mythread *pthread_t;

static DWORD WINAPI MyStart(void *arg)
{ Mythread *tv = (Mythread *) arg;

  tv->retval = tv->fct(tv->arg);
  return (0);
}

static int pthread_create(pthread_t *thread, void *attr,
                          void *(*fct)(void *), void *arg)
{ Mythread *tv;
  if (attr != NULL)
    { fprintf(stderr,"Do not support thread attributes\n");
      exit (1);
    }
  tv = (Mythread *) malloc(sizeof(Mythread));
  if (tv == NULL)
    { fprintf(stderr,"pthread_create: Out of memory.\n");
      exit (1);
    };
  tv->fct    = fct;
  tv->arg    = arg;
  tv->handle = CreateThread(NULL,0,MyStart,tv,0,&tv->id);
  if (tv->handle == NULL)
    return (EAGAIN);
  else
    return (0);
}

static int pthread_join(pthread_t t, void **ret)
{ Mythread *tv = (Mythread *) t;

  WaitForSingleObject(tv->handle,INFINITE);
  if (ret != NULL)
    *ret = tv->retval;

  CloseHandle(tv->handle);
  free(tv);
  return (0);
}

typedef int pthread_id;

static pthread_id pthread_tag()
{ return (GetCurrentThreadId()); }

static int pthread_is_this(pthread_id id)
{ return (GetCurrentThreadId() == id); }

#else   //  Small extension to pthreads!

#include <pthread.h>

typedef pthread_t pthread_id;

#define pthread_tag() pthread_self()

static inline int pthread_is_this(pthread_id id)
{ return (pthread_equal(pthread_self(),id)); }

#endif

/*****************************************************************************************\
*                                                                                         *
*  Array Data Abstraction                                                                 *
*                                                                                         *
*  Author:  Gene Myers                                                                    *
*  Date  :  December 2008                                                                 *
*                                                                                         *
*  (c) July 27, '09, Dr. Gene Myers and Howard Hughes Medical Institute                   *
*      Copyrighted as per the full copy in the associated 'README' file                   *
*                                                                                         *
\*****************************************************************************************/
 
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <float.h>
#include <math.h>

#include <stdint.h>
#include <float.h>

#define UINT8_MIN  0
#define UINT16_MIN 0
#define UINT32_MIN 0
#define UINT64_MIN 0

#include "mylib.h"
#include "utilities.h"
#include "array.h"
#include "linear.algebra.h"

#define BND_ZERO    0
#define BND_REFLECT 1
#define BND_WRAP    2
#define BND_EXTEND  3
#define BND_INVERT  4

extern int Boundary_Case_8qm5;




#define SIZEOF(x) ((int) sizeof(x))

/****************************************************************************************
 *                                                                                      *
 *  ARRAY SIZE, SHAPE & TYPE COMPARISONS                                                *
 *                                                                                      *
 ****************************************************************************************/

static Size_Type array_size(Array *a)
{ Size_Type p;
  int       i;
  p = 1;
  for (i = 0; i < a->ndims; i++)
    p *= a->dims[i];
  return (p);
}

boolean Same_Shape(AForm *a, AForm *b)
{ int         i;
  boolean     eq;
  int         andims, bndims;
  Dimn_Type  *adims, *bdims;
  Coordinate *ashape, *bshape;

  if (Is_Array(a))
    { andims = ((Array *) a)->ndims;
      adims  = ((Array *) a)->dims;
      ashape = NULL;
    }
  else
    { if (Is_Slice(a))
        ashape = AForm_Shape(a);
      else
        ashape = Frame_Shape(a);
      andims = ashape->dims[0];
      adims  = ADIMN(ashape);
    }

  if (Is_Array(b))
    { bndims = ((Array *) b)->ndims;
      bdims  = ((Array *) b)->dims;
      bshape = NULL;
    }
  else
    { if (Is_Slice(b))
        bshape = AForm_Shape(b);
      else
        bshape = Frame_Shape(b);
      bndims = bshape->dims[0];
      bdims  = ADIMN(bshape);
    }
    
  eq = 0;
  if (andims == bndims)
    { for (i = 0; i < andims; i++)
        if (adims[i] != bdims[i])
          break;
      eq = (i >= andims);
    }

  if (Is_Slice(a))
    Free_Array(ashape);
  if (Is_Slice(b))
    Free_Array(bshape);

  return (eq);
}

boolean Same_Type(AForm *a, AForm *b)
{ if (AForm_Array(a)->type != AForm_Array(b)->type)
    return (0);
  return (Same_Shape(a,b));
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY SPACE MANAGEMENT ROUTINES                                                     *
 *                                                                                      *
 ****************************************************************************************/

// Awk-generated (manager.awk) Array memory management

static int type_size[] = { 1, 2, 4, 8, 1, 2, 4, 8, 4, 8 };

static int bit_size[] = { 8, 16, 32, 64, 8, 16, 32, 64, 32, 64 };

static int kind_size[] = { 1, 3, 4, 2 };

static Value_Kind type2kind[] = { UVAL, UVAL, UVAL, UVAL, IVAL, IVAL, IVAL, IVAL, FVAL, FVAL };

static inline int array_nsize(Array *a)
{ return (SIZEOF(int)*a->ndims); }

static inline int64 array_dsize(Array *a)
{ return (a->size*type_size[a->type]); }

static inline int array_tsize(Array *a)
{ return (a->tlen+1); }


typedef struct __Array
  { struct __Array *next;
    struct __Array *prev;
    int             refcnt;
    int             nsize;
    int64          dsize;
    int             tsize;
    Array           array;
  } _Array;

static _Array *Free_Array_List = NULL;
static _Array *Use_Array_List  = NULL;

static pthread_mutex_t Array_Mutex = PTHREAD_MUTEX_INITIALIZER;

static int Array_Offset = sizeof(_Array)-sizeof(Array);
static int Array_Inuse  = 0;

int Array_Refcount(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->refcnt);
}

static inline int allocate_array_dims(Array *array, int nsize, char *routine)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  if (object->nsize < nsize)
    { void *x = Guarded_Realloc(array->dims,(size_t) nsize,routine);
      if (x == NULL) return (1);
      array->dims = x;
      object->nsize = nsize;
    }
  return (0);
}

static inline int sizeof_array_dims(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->nsize);
}

static inline int allocate_array_data(Array *array, int64 dsize, char *routine)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  if (object->dsize < dsize)
    { void *x = Guarded_Realloc(array->data,(size_t) dsize,routine);
      if (x == NULL) return (1);
      array->data = x;
      object->dsize = dsize;
    }
  return (0);
}

static inline int64 sizeof_array_data(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->dsize);
}

static inline int allocate_array_text(Array *array, int tsize, char *routine)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  if (object->tsize < tsize)
    { void *x = Guarded_Realloc(array->text,(size_t) tsize,routine);
      if (x == NULL) return (1);
      array->text = x;
      object->tsize = tsize;
    }
  return (0);
}

static inline int sizeof_array_text(Array *array)
{ _Array *object = (_Array *) (((char *) array) - Array_Offset);
  return (object->tsize);
}

static inline void kill_array(Array *array);

static inline Array *new_array(int nsize, int64 dsize, int tsize, char *routine)
{ _Array *object;
  Array  *array;

  pthread_mutex_lock(&Array_Mutex);
  if (Free_Array_List == NULL)
    { object = (_Array *) Guarded_Realloc(NULL,sizeof(_Array),routine);
      if (object == NULL) return (NULL);
      array = &(object->array);
      object->nsize = 0;
      array->dims = NULL;
      object->dsize = 0;
      array->data = NULL;
      object->tsize = 0;
      array->text = NULL;
    }
  else
    { object = Free_Array_List;
      Free_Array_List = object->next;
      array = &(object->array);
    }
  Array_Inuse += 1;
  object->refcnt = 1;
  if (Use_Array_List != NULL)
    Use_Array_List->prev = object;
  object->next = Use_Array_List;
  object->prev = NULL;
  Use_Array_List = object;
  pthread_mutex_unlock(&Array_Mutex);
  if (allocate_array_dims(array,nsize,routine))
    { kill_array(array);
      return (NULL);
    }
  if (allocate_array_data(array,dsize,routine))
    { kill_array(array);
      return (NULL);
    }
  if (allocate_array_text(array,tsize,routine))
    { kill_array(array);
      return (NULL);
    }
  return (array);
}

static inline Array *copy_array(Array *array)
{ Array *copy = new_array(array_nsize(array),array_dsize(array),array_tsize(array),"Copy_Array");
  void *_dims = copy->dims;
  void *_data = copy->data;
  void *_text = copy->text;
  *copy = *array;
  copy->dims = _dims;
  if (array->dims != NULL)
    memcpy(copy->dims,array->dims,(size_t) array_nsize(array));
  copy->data = _data;
  if (array->data != NULL)
    memcpy(copy->data,array->data,(size_t) array_dsize(array));
  copy->text = _text;
  if (array->text != NULL)
    memcpy(copy->text,array->text,(size_t) array_tsize(array));
  return (copy);
}

Array *Copy_Array(Array *array)
{ return ((Array *) copy_array(array)); }

static inline int pack_array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  if (object->nsize > array_nsize(array))
    { int ns = array_nsize(array);
      if (ns != 0)
        { void *x = Guarded_Realloc(array->dims,(size_t) ns,"Pack_Array");
          if (x == NULL) return (1);
          array->dims = x;
        }
      else
        { free(array->dims);
          array->dims = NULL;
        }
      object->nsize = ns;
    }
  if (object->dsize > array_dsize(array))
    { int64 ns = array_dsize(array);
      if (ns != 0)
        { void *x = Guarded_Realloc(array->data,(size_t) ns,"Pack_Array");
          if (x == NULL) return (1);
          array->data = x;
        }
      else
        { free(array->data);
          array->data = NULL;
        }
      object->dsize = ns;
    }
  if (object->tsize > array_tsize(array))
    { int ns = array_tsize(array);
      if (ns != 0)
        { void *x = Guarded_Realloc(array->text,(size_t) ns,"Pack_Array");
          if (x == NULL) return (1);
          array->text = x;
        }
      else
        { free(array->text);
          array->text = NULL;
        }
      object->tsize = ns;
    }
  return (0);
}

Array *Pack_Array(Array *array)
{ if (pack_array(array)) return (NULL);
  return (array);
}

Array *Inc_Array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  pthread_mutex_lock(&Array_Mutex);
  object->refcnt += 1;
  pthread_mutex_unlock(&Array_Mutex);
  return (array);
}

static inline void free_array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  pthread_mutex_lock(&Array_Mutex);
  if (--object->refcnt > 0)
    { pthread_mutex_unlock(&Array_Mutex);
      return;
    }
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Freeing previously released Array\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Array_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  object->next = Free_Array_List;
  Free_Array_List = object;
  Array_Inuse -= 1;
  pthread_mutex_unlock(&Array_Mutex);
}

void Free_Array(Array *array)
{ free_array(array); }

static inline void kill_array(Array *array)
{ _Array *object  = (_Array *) (((char *) array) - Array_Offset);
  pthread_mutex_lock(&Array_Mutex);
  if (--object->refcnt > 0)
    { pthread_mutex_unlock(&Array_Mutex);
      return;
    }
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Killing previously released Array\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Array_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  Array_Inuse -= 1;
  pthread_mutex_unlock(&Array_Mutex);
  if (array->text != NULL)
    free(array->text);
  if (array->data != NULL)
    free(array->data);
  if (array->dims != NULL)
    free(array->dims);
  free(((char *) array) - Array_Offset);
}

void Kill_Array(Array *array)
{ kill_array(array); }

static inline void reset_array()
{ _Array *object;
  Array  *array;
  pthread_mutex_lock(&Array_Mutex);
  while (Free_Array_List != NULL)
    { object = Free_Array_List;
      Free_Array_List = object->next;
      array = &(object->array);
      if (array->text != NULL)
        free(array->text);
      if (array->data != NULL)
        free(array->data);
      if (array->dims != NULL)
        free(array->dims);
      free(object);
    }
  pthread_mutex_unlock(&Array_Mutex);
}

void Reset_Array()
{ reset_array(); }

int Array_Usage()
{ return (Array_Inuse); }

void Array_List(void (*handler)(Array *))
{ _Array *a, *b;
  for (a = Use_Array_List; a != NULL; a = b)
    { b = a->next;
      handler((Array *) &(a->array));
    }
}

static inline Array *read_array(FILE *input)
{ char name[5];
  Array *obj;
  Array read;
  fread(name,5,1,input);
  if (strncmp(name,"Array",5) != 0)
    return (NULL);
  obj = new_array(0,0,0,"Read_Array");
  if (obj == NULL) return (NULL);
  read = *obj;
  if (fread(obj,sizeof(Array),1,input) == 0) goto error;
  obj->dims = read.dims;
  if (array_nsize(obj) != 0)
    { if (allocate_array_dims(obj,array_nsize(obj),"Read_Array")) goto error;
      if (fread(obj->dims,(size_t) array_nsize(obj),1,input) == 0) goto error;
    }
  obj->data = read.data;
  if (array_dsize(obj) != 0)
    { if (allocate_array_data(obj,array_dsize(obj),"Read_Array")) goto error;
      if (fread(obj->data,(size_t) array_dsize(obj),1,input) == 0) goto error;
    }
  obj->text = read.text;
  if (array_tsize(obj) != 0)
    { if (allocate_array_text(obj,array_tsize(obj),"Read_Array")) goto error;
      if (fread(obj->text,(size_t) array_tsize(obj),1,input) == 0) goto error;
    }
  return (obj);

error:
  kill_array(obj);
  return (NULL);
}

Array *Read_Array(FILE *input)
{ return ((Array *) read_array(input)); }

static inline void write_array(Array *array, FILE *output)
{ fwrite("Array",5,1,output);
  fwrite(array,sizeof(Array),1,output);
  if (array_nsize(array) != 0)
    fwrite(array->dims,(size_t) array_nsize(array),1,output);
  if (array_dsize(array) != 0)
    fwrite(array->data,(size_t) array_dsize(array),1,output);
  if (array_tsize(array) != 0)
    fwrite(array->text,(size_t) array_tsize(array),1,output);
}

void Write_Array(Array *array, FILE *output)
{ write_array(array,output); }


/****************************************************************************************
 *                                                                                      *
 *  MAKE AN ARRAY                                                                       *
 *                                                                                      *
 ****************************************************************************************/

static Array *make_start(Array_Kind kind, Value_Type type, int ndims, string routine)
{ Array  *a;

  a = new_array(SIZEOF(int)*ndims,0,1,routine);
  a->type    = type;
  a->kind    = kind;
  a->scale   = bit_size[type];
  a->text[0] = '\0';
  a->tlen    = 0;
  a->ndims   = ndims;
  return (a);
}

static Array *make_shape(Array_Kind kind, Value_Type type, int ndims, Dimn_Type *dims,
                         string routine)
{ Array *a;
  int    i, o, v;

  o = (kind != PLAIN_KIND);
  v = (kind == COMPLEX_KIND);
  a = make_start(kind,type,ndims+o,routine);
  if (v)
    a->dims[0] = kind_size[kind];
  for (i = 0; i < ndims; i++)
    a->dims[i+v] = dims[i];
  if (o & !v)
    a->dims[ndims] = kind_size[kind];
  a->size = array_size(a);
  return (a);
}

Array *G(Make_Array)(Array_Kind kind, Value_Type type, int ndims, Dimn_Type *dims)
{ Array *a;

  a = make_shape(kind,type,ndims,dims,"Make_Array");

  allocate_array_data(a,array_dsize(a),"Make_Array");

  return (a);
}

Array *G(Make_Array_With_Shape)(Array_Kind kind, Value_Type type, Coordinate *F(shape))
{ Array *a;

  a = make_shape(kind,type,shape->dims[0],ADIMN(shape),"Make_Array_With_Shape");

  allocate_array_data(a,array_dsize(a),"Make_Array_With_Shape");

  Free_Array(shape);

  return (a);
}

Array *G(Make_Array_Of_Data)(Array_Kind kind, Value_Type type, int ndims, Dimn_Type *dims,
                             void *data)
{ Array *a;

  a = make_shape(kind,type,ndims,dims,"Make_Array_Of_Data");

  { _Array *object = (_Array *) (((char *) a) - Array_Offset);
    if (object->dsize > 0)
      free(a->data);
    object->dsize  = array_dsize(a);
    a->data = data;
  }

  return (a);
}

Array *G(Make_Array_From_Arrays)(Array_Kind kind, int n, Array **arrays)
{ Array    *a, *a0;
  int       i, ndims;
  Size_Type dsize;

  a0 = arrays[0];
  if (n > 1)
    { for (i = 1; i < n; i++)
        if ( ! Same_Type(arrays[i],a0))
          { fprintf(stderr,
               "Arrays are not all of the same type and shape (Make_Array_From_Arrays)\n");
            exit (1);
          }
    }
  if (kind == COMPLEX_KIND && a0->ndims > 0)
    { for (i = 0; i < n; i++)
        if (arrays[i]->kind != COMPLEX_KIND)
          { fprintf(stderr,"Arrays must all be COMPLEX (Make_Array_From_Arrays)\n");
            exit (1);
          }
    }
  else
    { for (i = 0; i < n; i++)
        if (arrays[i]->kind != PLAIN_KIND)
          { fprintf(stderr,"Arrays must all be PLAIN (Make_Array_From_Arrays)\n");
            exit (1);
          }
    }
  if (kind != PLAIN_KIND && (kind != COMPLEX_KIND || a0->ndims == 0) && n != kind_size[kind])
    { fprintf(stderr,"Outer dimension and kind are not consistent (Make_Array_From_Arrays)\n");
      exit (1);
    }

  dsize = array_dsize(arrays[0]);
  ndims = a0->ndims;

  a = new_array(SIZEOF(int)*(ndims+1),n*dsize,1,"Make_Array_From_Arrays");

  a->type    = a0->type;
  a->kind    = kind;
  a->scale   = a0->scale;
  a->tlen    = 0;
  a->text[0] = '\0';
  a->ndims   = ndims+1;
  for (i = 0; i < ndims; i++)
    a->dims[i] = a0->dims[i];
  a->dims[ndims] = n;
  a->size        = n * a0->size;

  for (i = 0; i < n; i++)
    memcpy(((char *) a->data) + i*dsize, arrays[i]->data, (size_t) dsize);

  return (a);
}


/****************************************************************************************
 *                                                                                      *
 *  COORDS, GET & SET                                                                   *
 *                                                                                      *
 ****************************************************************************************/

static Dimn_Type  Coord_Ndim, Coord_Max = 0;
static Dimn_Type *Coord_Dims;
static Array_Kind Coord_Kind;

static pthread_mutex_t Coord_Mutex = PTHREAD_MUTEX_INITIALIZER;

void Set_Coord_Basis(Coordinate *F(point), Array_Kind kind)
{ pthread_mutex_lock(&Coord_Mutex);
  if (point == NULL)
    { Coord_Dims = NULL;
      Coord_Ndim = 0;
      return;
    }
  if (point->ndims != 1 || point->type != DIMN_TYPE)
    { fprintf(stderr,"Coordinate is not an unsigned integer vector (Set_Coord_Basis)\n");
      exit (1);
    }
  Coord_Ndim = point->dims[0];
  Coord_Kind = kind;
  if (Coord_Ndim > Coord_Max)
    { Coord_Max  = Coord_Ndim + 10;
      Coord_Dims = Guarded_Realloc(Coord_Dims,sizeof(Dimn_Type)*((size_t) Coord_Max),
                                   "Set_Coord_Basis");
    }
  memcpy(Coord_Dims,ADIMN(point),sizeof(Dimn_Type)*((size_t) Coord_Ndim));
  pthread_mutex_unlock(&Coord_Mutex);
  Free_Array(point);
}

Coordinate *G(Get_Coord_Basis)(Array_Kind *kind)
{ Dimn_Type  dim[1];
  Array     *point;

  if (Coord_Dims == NULL)
    return (NULL);
  pthread_mutex_lock(&Coord_Mutex);
  dim[0] = Coord_Ndim;
  point  = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dim);
  memcpy(ADIMN(point),Coord_Dims,sizeof(Dimn_Type)*((size_t) Coord_Ndim));
  *kind = Coord_Kind;
  pthread_mutex_unlock(&Coord_Mutex);
  return (point);
}

void Use_Array_Basis(Array *a)
{ pthread_mutex_lock(&Coord_Mutex);
  Coord_Ndim = a->ndims;
  Coord_Kind = a->kind;
  if (Coord_Ndim > Coord_Max)
    { Coord_Max  = Coord_Ndim + 10;
      Coord_Dims = Guarded_Realloc(Coord_Dims,sizeof(Dimn_Type)*((size_t) Coord_Max),
                                   "Use_Array_Basis");
    }
  memcpy(Coord_Dims,a->dims,sizeof(Dimn_Type)*((size_t) Coord_Ndim));
  pthread_mutex_unlock(&Coord_Mutex);
}

Coordinate *G(Coord)(string list)
{ Array     *coord;
  Dimn_Type  dim[1], *c;
  int        i, n;
  char      *b, *e;

  n = 1;
  for (i = 0; i < (int) strlen(list); i++)
    if (list[i] == ',')
      n += 1;

  dim[0] = n;
  coord  = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dim);

  c = ADIMN(coord);
  b = list;
  while (1)
    { c[--n] = (Dimn_Type) strtol(b,&e,10);
      if (b == e)
        { fprintf(stderr,"Not a valid constant coordinate list (Coord)\n");
          exit (1);
        }
      b = e;
      if (*b == '\0')
        break;
      if (*b++ != ',')
        { fprintf(stderr,"Not a valid constant coordinate list (Coord)\n");
          exit (1);
        }
    }

  return (coord);
}

void Print_Coord(FILE *file, Coordinate *point)
{ int  i, n;

  n = point->dims[0];
  switch (point->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(point);
          fprintf(file,"%u",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%u",d[i]);
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(point);
          fprintf(file,"%u",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%u",d[i]);
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(point);
          fprintf(file,"%u",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%u",d[i]);
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(point);
          fprintf(file,"%llu",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%llu",d[i]);
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(point);
          fprintf(file,"%d",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%d",d[i]);
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(point);
          fprintf(file,"%d",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%d",d[i]);
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(point);
          fprintf(file,"%d",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%d",d[i]);
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(point);
          fprintf(file,"%lld",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%lld",d[i]);
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(point);
          fprintf(file,"%g",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%g",d[i]);
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(point);
          fprintf(file,"%g",d[n-1]);
          for (i = n-2; i >= 0; i--)
            fprintf(file,",%g",d[i]);
          break;
        }
  }

  Free_Array(point);
}

Coordinate *G(Coord1)(Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 1;
  coord  = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  return (coord);
}

Coordinate *G(Coord2)(Dimn_Type d2, Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 2;
  coord  = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  c[1]   = d2;
  return (coord);
}

Coordinate *G(Coord3)(Dimn_Type d3, Dimn_Type d2, Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 3;
  coord  = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  c[1]   = d2;
  c[2]   = d3;
  return (coord);
}

Coordinate *G(Coord4)(Dimn_Type d4, Dimn_Type d3, Dimn_Type d2, Dimn_Type d1)
{ Array     *coord;
  Dimn_Type  dim[1], *c;

  dim[0] = 4;
  coord  = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dim);
  c      = ADIMN(coord);
  c[0]   = d1;
  c[1]   = d2;
  c[2]   = d3;
  c[3]   = d4;
  return (coord);
}

Indx_Type Coord2Idx(Coordinate *F(point))
{ Dimn_Type *x, y;
  Indx_Type  p;
  int        i;

  if (point->ndims != 1 || point->type != DIMN_TYPE)
    { fprintf(stderr,"Point is not an integer vector (Coord2Idx)\n");
      exit (1);
    }
  if (Coord_Dims == NULL)
    { fprintf(stderr,"Coordinate basis is not set (Coord2Idx)\n");
      exit (1);
    }
  pthread_mutex_lock(&Coord_Mutex);
  if (point->size != Coord_Ndim && (point->size != Coord_Ndim-1 || Coord_Kind == PLAIN_KIND))
    { fprintf(stderr,"Coordinate dimensionality doesn't match that of current basis (Coord2Idx)\n");
      exit (1);
    }
  if (point->size != Coord_Ndim)
    { if (Coord_Kind == COMPLEX_KIND)
        PrependCoord(point,0);
      else
        AppendCoord(0,point);
    }

  x = ADIMN(point);
  p = 0;
  for (i = Coord_Ndim-1; i >= 0; i--)
    { y = x[i];
      if (y >= Coord_Dims[i] || y < 0)
        { fprintf(stderr,"%d'th index out of bounds (Coord2Idx)\n",i+1);
          exit (1);
        }
      p = p*Coord_Dims[i] + y; 
    }
  pthread_mutex_unlock(&Coord_Mutex);

  Free_Array(point);

  return (p);
}

Indx_Type Coord2IdxA(Array *a, Coordinate *F(point))
{ Dimn_Type *x, *d, y;
  Indx_Type  p;
  int        n, i;

  if (point->ndims != 1 || point->type != DIMN_TYPE)
    { fprintf(stderr,"Point is not an integer vector (Coord2IdxA)\n");
      exit (1);
    }

  n = a->ndims;
  d = a->dims;

  if (point->size != n && (point->size != n-1 || a->kind == PLAIN_KIND))
   { fprintf(stderr,"Coordinate dimensionality doesn't match that of current basis (Coord2IdxA)\n");
     exit (1);
   }
  if (point->size != n)
    { if (Coord_Kind == COMPLEX_KIND)
        PrependCoord(point,0);
      else
        AppendCoord(0,point);
    }

  x = ADIMN(point);
  p = 0;
  for (i = n-1; i >= 0; i--)
    { y = x[i];
      if (y >= d[i] || y < 0)
        { fprintf(stderr,"%d'th index out of bounds (Coord2IdxA)\n",i+1);
          exit (1);
        }
      p = p*d[i] + y; 
    }

  Free_Array(point);

  return (p);
}

Coordinate *AppendCoord(Dimn_Type d, Coordinate *R(M(c)))
{ Dimn_Type n;
  n = c->dims[0];
  allocate_array_data(c,(n+1)*SIZEOF(Dimn_Type),"AppendCoord");
  c->dims[0]  = n+1;
  c->size     = n+1;
  ADIMN(c)[n] = d;
  return (c);
}

Coordinate *PrependCoord(Coordinate *R(M(c)), Dimn_Type d)
{ Dimn_Type *x = ADIMN(c);
  Dimn_Type  n;
  int        i;

  n = c->dims[0];
  allocate_array_data(c,(n+1)*SIZEOF(Dimn_Type),"PrependCoord");
  c->dims[0]  = n+1;
  c->size     = n+1;
  for (i = n; i > 0; i--)
    x[i] = x[i-1];
  x[0] = d;
  return (c);
}

static inline Coordinate *G(coord4idx)(int n, Dimn_Type *d, Indx_Type idx, string routine)
{ Dimn_Type   dims[1], m, *l;
  Coordinate *lat;
  int         i;

  dims[0] = n;
  lat     = Make_Array(PLAIN_KIND,DIMN_TYPE,1,dims);

  l = ADIMN(lat);
  for (i = 0; i < n; i++)
    { m = d[i];
      l[i] = (Dimn_Type) (idx % m);
      idx /= m;
    }
  if (idx > 0)
    { fprintf(stderr,"Index is out of array boundary (%s)\n",routine);
      exit (1);
    }
  return (lat);
}

Coordinate *G(Idx2Coord)(Indx_Type idx)
{ Coordinate *p;
  if (Coord_Dims == NULL)
    { fprintf(stderr,"Coordinate basis is not set (Idx2Coord)\n");
      exit (1);
    }
  pthread_mutex_lock(&Coord_Mutex);
  p = coord4idx(Coord_Ndim,Coord_Dims,idx,"Idx2Coord");
  pthread_mutex_unlock(&Coord_Mutex);
  return (p);
}

Coordinate *G(Idx2CoordA)(Array *a, Indx_Type idx)
{ return (coord4idx(a->ndims,a->dims,idx,"Idx2CoordA")); }

Coordinate *G(Idx2Core)(Indx_Type idx)
{ Dimn_Type  *d;
  int         n;
  Coordinate *p;

  if (Coord_Dims == NULL)
    { fprintf(stderr,"Coordinate basis is not set (Idx2Coord)\n");
      exit (1);
    }

  pthread_mutex_lock(&Coord_Mutex);
  d = Coord_Dims;
  n = Coord_Ndim;
  if (Coord_Kind != PLAIN_KIND)
    { if (Coord_Kind == COMPLEX_KIND)
        d += 1;
      n -= 1;
      idx /= kind_size[Coord_Kind];
    }

  p = coord4idx(n,d,idx,"Idx2Core");
  pthread_mutex_unlock(&Coord_Mutex);
  return (p);
}

Coordinate *G(Idx2CoreA)(Array *a, Indx_Type idx)
{ Dimn_Type  *d;
  int         n;

  d = a->dims;
  n = a->ndims;
  if (a->kind != PLAIN_KIND)
    { if (a->kind == COMPLEX_KIND)
        d += 1;
      n -= 1;
      idx /= kind_size[a->kind];
    }

  return (coord4idx(n,d,idx,"Idx2CoreA"));
}

Value Get_Array_Value(Array *a, Coordinate *coord)
{ Indx_Type p = Coord2IdxA(a,coord);
  Value     v;
  switch (a->type) {
      case UINT8_TYPE:
        v.uval = AUINT8(a)[p];
        break;
      case UINT16_TYPE:
        v.uval = AUINT16(a)[p];
        break;
      case UINT32_TYPE:
        v.uval = AUINT32(a)[p];
        break;
      case UINT64_TYPE:
        v.uval = AUINT64(a)[p];
        break;
      case INT8_TYPE:
        v.ival = AINT8(a)[p];
        break;
      case INT16_TYPE:
        v.ival = AINT16(a)[p];
        break;
      case INT32_TYPE:
        v.ival = AINT32(a)[p];
        break;
      case INT64_TYPE:
        v.ival = AINT64(a)[p];
        break;
      case FLOAT32_TYPE:
        v.fval = AFLOAT32(a)[p];
        break;
      case FLOAT64_TYPE:
        v.fval = AFLOAT64(a)[p];
        break;
  }
  return (v);
}

void Set_Array_Value(Array *M(a), Coordinate *coord, Value v)
{ Indx_Type p = Coord2IdxA(a,coord);
  switch (a->type) {
      case UINT8_TYPE:
        AUINT8(a)[p] = (uint8) v.uval;
        break;
      case UINT16_TYPE:
        AUINT16(a)[p] = (uint16) v.uval;
        break;
      case UINT32_TYPE:
        AUINT32(a)[p] = (uint32) v.uval;
        break;
      case UINT64_TYPE:
        AUINT64(a)[p] = (uint64) v.uval;
        break;
      case INT8_TYPE:
        AINT8(a)[p] = (int8) v.ival;
        break;
      case INT16_TYPE:
        AINT16(a)[p] = (int16) v.ival;
        break;
      case INT32_TYPE:
        AINT32(a)[p] = (int32) v.ival;
        break;
      case INT64_TYPE:
        AINT64(a)[p] = (int64) v.ival;
        break;
      case FLOAT32_TYPE:
        AFLOAT32(a)[p] = (float32) v.fval;
        break;
      case FLOAT64_TYPE:
        AFLOAT64(a)[p] = (float64) v.fval;
        break;
  }
}

Coordinate *G(Floor_Coord)(Double_Vector *point)
{ Array     *lat;
  double    *p;
  Dimn_Type *c, k;

  if (point->ndims != 1 || point->kind != PLAIN_KIND || point->type != FLOAT64_TYPE)
    { fprintf(stderr,"Point is not a double vector (Floor_Coord)\n");
      exit (1);
    }

  lat = Make_Array(PLAIN_KIND,DIMN_TYPE,1,point->dims);

  p = AFLOAT64(point);
  c = ADIMN(lat);
  for (k = 0; k < point->dims[0]; k++)
    c[k] = (Dimn_Type) floor(p[k]);

  return (lat);
}

Coordinate *G(Ceiling_Coord)(Double_Vector *point)
{ Array     *lat;
  double    *p;
  Dimn_Type *c, k;

  if (point->ndims != 1 || point->kind != PLAIN_KIND || point->type != FLOAT64_TYPE)
    { fprintf(stderr,"Point is not a double vector (Ceiling_Coord)\n");
      exit (1);
    }

  lat = Make_Array(PLAIN_KIND,DIMN_TYPE,1,point->dims);

  p = AFLOAT64(point);
  c = ADIMN(lat);
  for (k = 0; k < point->dims[0]; k++)
    c[k] = (Dimn_Type) ceil(p[k]);

  return (lat);
}

Coordinate *G(Nearest_Coord)(Double_Vector *point)
{ Array     *lat;
  double    *p;
  Dimn_Type *c, k;

  if (point->ndims != 1 || point->kind != PLAIN_KIND || point->type != FLOAT64_TYPE)
    { fprintf(stderr,"Point is not a double vector (Floor_Coord)\n");
      exit (1);
    }

  lat = Make_Array(PLAIN_KIND,DIMN_TYPE,1,point->dims);

  p = AFLOAT64(point);
  c = ADIMN(lat);
  for (k = 0; k < point->dims[0]; k++)
    c[k] = (Dimn_Type) floor(p[k]+.5);

  return (lat);
}


/****************************************************************************************
 *                                                                                      *
 *  SLICE ITERATOR ROUTINES                                                             *
 *                                                                                      *
 ****************************************************************************************/

#define SLICE_KIND  4

typedef struct
  { Array_Kind  kind;     //  Always SLICE_KIND in order to distinguish from an Array
    Array      *trg_ref;  //  The array the slice is in.
    Coordinate *beg;      //  References to the beg and end coordinate defining slice
    Coordinate *end;

    int         ndims;    //  Dimensionality of slice
    Size_Type   size;     //  Size of slice (# of pixels)

    Coordinate *cnt;      //  Current coordinate (= index)
    Indx_Type   p;        //  Current index
    int         clip;     //  Highest dimension currently outside of slice
    Size_Type  *dnc;      //  dnc[i] = displacement to next slice element when at an i boundary

    Dimn_Type  *acnt;     //  Direct access to elements above to speed computation
    Dimn_Type  *bcrd;
    Dimn_Type  *ecrd;
  } Slicer;

static inline int slicer_dsize(Slicer *s)
{ return (SIZEOF(Size_Type)*s->ndims); }


typedef struct __Slicer
  { struct __Slicer *next;
    struct __Slicer *prev;
    int              refcnt;
    int              dsize;
    Slicer           slicer;
  } _Slicer;

static _Slicer *Free_Slicer_List = NULL;
static _Slicer *Use_Slicer_List  = NULL;

static pthread_mutex_t Slicer_Mutex = PTHREAD_MUTEX_INITIALIZER;

static int Slicer_Offset = sizeof(_Slicer)-sizeof(Slicer);
static int Slicer_Inuse  = 0;

int Slice_Refcount(Slice *slice)
{ _Slicer *object = (_Slicer *) (((char *) slice) - Slicer_Offset);
  return (object->refcnt);
}

static inline int allocate_slicer_dnc(Slicer *slicer, int dsize, char *routine)
{ _Slicer *object = (_Slicer *) (((char *) slicer) - Slicer_Offset);
  if (object->dsize < dsize)
    { void *x = Guarded_Realloc(slicer->dnc,(size_t) dsize,routine);
      if (x == NULL) return (1);
      slicer->dnc = x;
      object->dsize = dsize;
    }
  return (0);
}

static inline int sizeof_slicer_dnc(Slicer *slicer)
{ _Slicer *object = (_Slicer *) (((char *) slicer) - Slicer_Offset);
  return (object->dsize);
}

static inline void kill_slicer(Slicer *slicer);

static inline Slicer *new_slicer(int dsize, char *routine)
{ _Slicer *object;
  Slicer  *slicer;

  pthread_mutex_lock(&Slicer_Mutex);
  if (Free_Slicer_List == NULL)
    { object = (_Slicer *) Guarded_Realloc(NULL,sizeof(_Slicer),routine);
      if (object == NULL) return (NULL);
      slicer = &(object->slicer);
      object->dsize = 0;
      slicer->dnc = NULL;
    }
  else
    { object = Free_Slicer_List;
      Free_Slicer_List = object->next;
      slicer = &(object->slicer);
    }
  Slicer_Inuse += 1;
  object->refcnt = 1;
  if (Use_Slicer_List != NULL)
    Use_Slicer_List->prev = object;
  object->next = Use_Slicer_List;
  object->prev = NULL;
  Use_Slicer_List = object;
  pthread_mutex_unlock(&Slicer_Mutex);
  slicer->cnt = NULL;
  slicer->beg = NULL;
  slicer->end = NULL;
  slicer->trg_ref = NULL;
  if (allocate_slicer_dnc(slicer,dsize,routine))
    { kill_slicer(slicer);
      return (NULL);
    }
  return (slicer);
}

static inline Slicer *copy_slicer(Slicer *slicer)
{ Slicer *copy = new_slicer(slicer_dsize(slicer),"Copy_Slice");
  void *_dnc = copy->dnc;
  *copy = *slicer;
  if (slicer->cnt != NULL)
    copy->cnt = Copy_Array(slicer->cnt);
  if (slicer->beg != NULL)
    copy->beg = Copy_Array(slicer->beg);
  if (slicer->end != NULL)
    copy->end = Copy_Array(slicer->end);
  if (slicer->trg_ref != NULL)
    Inc_Array(slicer->trg_ref);
  copy->dnc = _dnc;
  if (slicer->dnc != NULL)
    memcpy(copy->dnc,slicer->dnc,(size_t) slicer_dsize(slicer));
  return (copy);
}

Slice *Copy_Slice(Slice *slice)
{ return ((Slice *) copy_slicer(((Slicer *) slice))); }

static inline int pack_slicer(Slicer *slicer)
{ _Slicer *object  = (_Slicer *) (((char *) slicer) - Slicer_Offset);
  if (slicer->cnt != NULL)
    if (Pack_Array(slicer->cnt) == NULL) return (1);
  if (slicer->beg != NULL)
    if (Pack_Array(slicer->beg) == NULL) return (1);
  if (slicer->end != NULL)
    if (Pack_Array(slicer->end) == NULL) return (1);
  if (object->dsize > slicer_dsize(slicer))
    { int ns = slicer_dsize(slicer);
      if (ns != 0)
        { void *x = Guarded_Realloc(slicer->dnc,(size_t) ns,"Pack_Slicer");
          if (x == NULL) return (1);
          slicer->dnc = x;
        }
      else
        { free(slicer->dnc);
          slicer->dnc = NULL;
        }
      object->dsize = ns;
    }
  return (0);
}

Slice *Inc_Slice(Slice *slice)
{ _Slicer *object  = (_Slicer *) (((char *) slice) - Slicer_Offset);
  pthread_mutex_lock(&Slicer_Mutex);
  object->refcnt += 1;
  pthread_mutex_unlock(&Slicer_Mutex);
  return (slice);
}

static inline void free_slicer(Slicer *slicer)
{ _Slicer *object  = (_Slicer *) (((char *) slicer) - Slicer_Offset);
  pthread_mutex_lock(&Slicer_Mutex);
  if (--object->refcnt > 0)
    { pthread_mutex_unlock(&Slicer_Mutex);
      return;
    }
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Freeing previously released Slice\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Slicer_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  object->next = Free_Slicer_List;
  Free_Slicer_List = object;
  Slicer_Inuse -= 1;
  pthread_mutex_unlock(&Slicer_Mutex);
  if (slicer->trg_ref != NULL)
    { Free_Array(slicer->trg_ref);
      slicer->trg_ref = NULL;
    }
  if (slicer->end != NULL)
    { Free_Array(slicer->end);
      slicer->end = NULL;
    }
  if (slicer->beg != NULL)
    { Free_Array(slicer->beg);
      slicer->beg = NULL;
    }
  if (slicer->cnt != NULL)
    { Free_Array(slicer->cnt);
      slicer->cnt = NULL;
    }
}

void Free_Slice(Slice *slice)
{ free_slicer(((Slicer *) slice)); }

static inline void kill_slicer(Slicer *slicer)
{ _Slicer *object  = (_Slicer *) (((char *) slicer) - Slicer_Offset);
  pthread_mutex_lock(&Slicer_Mutex);
  if (--object->refcnt > 0)
    { pthread_mutex_unlock(&Slicer_Mutex);
      return;
    }
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Killing previously released Slice\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Slicer_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  Slicer_Inuse -= 1;
  pthread_mutex_unlock(&Slicer_Mutex);
  if (slicer->dnc != NULL)
    free(slicer->dnc);
  if (slicer->trg_ref != NULL)
    Kill_Array(slicer->trg_ref);
  if (slicer->end != NULL)
    Kill_Array(slicer->end);
  if (slicer->beg != NULL)
    Kill_Array(slicer->beg);
  if (slicer->cnt != NULL)
    Kill_Array(slicer->cnt);
  free(((char *) slicer) - Slicer_Offset);
}

void Kill_Slice(Slice *slice)
{ kill_slicer(((Slicer *) slice)); }

static inline void reset_slicer()
{ _Slicer *object;
  Slicer  *slicer;
  pthread_mutex_lock(&Slicer_Mutex);
  while (Free_Slicer_List != NULL)
    { object = Free_Slicer_List;
      Free_Slicer_List = object->next;
      slicer = &(object->slicer);
      if (slicer->dnc != NULL)
        free(slicer->dnc);
      free(object);
    }
  pthread_mutex_unlock(&Slicer_Mutex);
}

void Reset_Slice()
{ reset_slicer(); }

int Slice_Usage()
{ return (Slicer_Inuse); }

void Slice_List(void (*handler)(Slice *))
{ _Slicer *a, *b;
  for (a = Use_Slicer_List; a != NULL; a = b)
    { b = a->next;
      handler((Slice *) &(a->slicer));
    }
}

Slice *Pack_Slice(Slice *s)
{ Slicer *o = (Slice *) s;
  boolean nok = pack_slicer(o);
  o->acnt = ADIMN(o->cnt);
  o->bcrd = ADIMN(o->beg);
  o->ecrd = ADIMN(o->end);
  if (nok) return (NULL);
  return (s);
}

Slice *G(Make_Slice)(Array *I(target), Coordinate *S(beg), Coordinate *S(end))
{ Slicer    *slice;
  Dimn_Type *ecrd = ADIMN(end);
  Dimn_Type *bcrd = ADIMN(beg);
  Dimn_Type *dims;
  int        i, ndims;

  if (beg->ndims != 1 || beg->type != DIMN_TYPE)
    { fprintf(stderr,"Beg is not a coordinate vector (Make_Slice)\n");
      exit (1);
    }
  if (end->ndims != 1 || end->type != DIMN_TYPE)
    { fprintf(stderr,"End is not a coordinate vector (Make_Slice)\n");
      exit (1);
    }
  if (Array_Refcount(beg) != 1)
    { fprintf(stderr,"Beg is not subsumable, has a reference count > 1 (Make_Slice)\n");
      exit (1);
    }
  if (Array_Refcount(end) != 1)
    { fprintf(stderr,"End is not subsumable, has a reference count > 1 (Make_Slice)\n");
      exit (1);
    }

  ndims = (int) beg->size;
  if (target->ndims != ndims && (target->ndims-1 != ndims || target->kind == PLAIN_KIND))
    { fprintf(stderr,"Target and coordinate dimensionality do not match (Make_Slice)\n");
      exit (1);
    }
  if (end->size != ndims)
    { fprintf(stderr,"Begin and end coordinate dimensionality do not match (Make_Slice)\n");
      exit (1);
    }

  if (ndims == target->ndims-1 && target->kind == COMPLEX_KIND)
    dims = target->dims+1;
  else
    dims = target->dims;
  for (i = 0; i < ndims; i++)
    { if (bcrd[i] > ecrd[i])
        { fprintf(stderr,"beg is not before end in target array (Make_Slice)\n");
          exit (1);
        }
      if (ecrd[i] >= dims[i])
        { fprintf(stderr,"end is not in basis of target array (Make_Slice)\n");
          exit (1);
        }
      if (bcrd[i] < 0)
        { fprintf(stderr,"beg is not in basis of target array (Make_Slice)\n");
          exit (1);
        }
    }
  dims = target->dims;

  if (ndims == target->ndims-1)
    { ndims += 1;
      if (target->kind == COMPLEX_KIND)
        { PrependCoord(beg,0);
          PrependCoord(end,1);
        }
      else
        { AppendCoord(0,beg);
          AppendCoord(kind_size[target->kind]-1,end);
        }
      bcrd = ADIMN(beg);
      ecrd = ADIMN(end);
    }

  slice = new_slicer(ndims*SIZEOF(Size_Type),"Make_Slice");

  slice->kind    = SLICE_KIND;
  slice->trg_ref = Inc_Array(target);
  slice->beg     = beg;
  slice->end     = end;

  slice->ndims = ndims;
  slice->size  = 1;
  for (i = 0; i < ndims; i++)
    slice->size *= (ecrd[i] - bcrd[i]) + 1;

  slice->cnt = Copy_Array(beg);

  { Size_Type *dinc = slice->dnc;
    Size_Type  offset, outer;

    offset  = 0;
    outer   = 1;
    for (i = 0; i < ndims; i++)
      { dinc[i] = outer-offset;
        offset += (ecrd[i]-bcrd[i])*outer;
        outer  *= dims[i];
      }

    slice->p = Coord2IdxA(target,Inc_Array(beg));
    slice->clip = -1;
  }

  slice->acnt = ADIMN(slice->cnt);
  slice->bcrd = bcrd;
  slice->ecrd = ecrd;

  return ((Slice *) slice);
}

Indx_Type Slice_Index(Slice *slicer)
{ return (((Slicer *) slicer)->p);  }

Coordinate *Slice_Coordinate(Slice *slicer)
{ return (((Slicer *) slicer)->cnt); }

Coordinate *Slice_First(Slice *slicer)
{ return (((Slicer *) slicer)->beg); }

Coordinate *Slice_Last(Slice *slicer)
{ return (((Slicer *) slicer)->end); }

boolean Inside_Slice(Slice *slicer)
{ return (((Slicer *) slicer)->clip < 0);  }

boolean Set_Slice_To_Index(Slice *M(slicer), Size_Type idx)
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd  = slice->bcrd;
  Dimn_Type *ecrd  = slice->ecrd;
  Dimn_Type *cnt   = slice->acnt;
  Dimn_Type *dim   = slice->trg_ref->dims;
  int        ndims = slice->ndims;
  Dimn_Type  d, c;
  int        i;

  if (idx >= slice->trg_ref->size)
    { fprintf(stderr,"Index is not in target array basis (Set_Slice_To_Index)\n");
      exit (1);
    }

  slice->p    = idx;
  slice->clip = -1;
  for (i = 0; i < ndims; i++)
    { d = dim[i];
      cnt[i] = c = (Dimn_Type) (idx % d);
      if (c < bcrd[i] || c > ecrd[i])
        slice->clip = i;
      idx = idx / d;
    }
  return (slice->clip < 0);
}

Indx_Type Set_Slice_To_First(Slice *M(slicer))
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd  = slice->bcrd;
  Dimn_Type *dim   = slice->trg_ref->dims;
  Dimn_Type *cnt   = slice->acnt;
  int        ndims = slice->ndims;
  int        i;

  slice->p = 0;
  for (i = ndims-1; i >= 0; i--)
    { cnt[i] = bcrd[i];
      slice->p = slice->p * dim[i] + bcrd[i];
    }
  slice->clip = -1;
  return (slice->p);
}

Indx_Type Set_Slice_To_Last(Slice *M(slicer))
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *ecrd  = slice->ecrd;
  Dimn_Type *dim   = slice->trg_ref->dims;
  Dimn_Type *cnt   = slice->acnt;
  int        ndims = slice->ndims;
  int        i;

  slice->p = 0;
  for (i = ndims-1; i >= 0; i--)
    { cnt[i] = ecrd[i];
      slice->p = slice->p * dim[i] + ecrd[i];
    }
  slice->clip = -1;
  return (slice->p);
}

Indx_Type Next_Slice_Index(Slice *M(slicer))
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *ecrd  = slice->ecrd;
  Dimn_Type *cnt   = slice->acnt;
  int        i;

  if (slice->clip >= 0)
    { fprintf(stderr,"Must be in slice to move to next position (Next_Slice_Index)\n");
      exit (1);
    }

  if (++cnt[0] <= ecrd[0])
    return (slice->p += 1);
  else
    { int        ndims = slice->ndims;
      Dimn_Type *bcrd  = slice->bcrd;

      cnt[0] = bcrd[0];
      for (i = 1; i < ndims; i++)
        if (++cnt[i] > ecrd[i])
          cnt[i] = bcrd[i];
        else
          return (slice->p += slice->dnc[i]);
    }
  slice->p = Coord2IdxA(slice->trg_ref,Inc_Array(slice->beg));
  return (slice->p);
}

Indx_Type Prev_Slice_Index(Slice *M(slicer))
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *bcrd  = slice->bcrd;
  Dimn_Type *cnt   = slice->acnt;
  int        i;

  if (slice->clip >= 0)
    { fprintf(stderr,"Must be in slice to move to next position (Prev_Slice_Index)\n");
      exit (1);
    }

  if (cnt[0]-- > bcrd[0])
    return (slice->p -= 1);
  else
    { int        ndims = slice->ndims;
      Dimn_Type *ecrd  = slice->ecrd;

      cnt[0] = ecrd[0];
      for (i = 1; i < ndims; i++)
        if (cnt[i]-- <= bcrd[i])
          cnt[i] = ecrd[i];
        else
          return (slice->p -= slice->dnc[i]);
    }
  slice->p = Coord2IdxA(slice->trg_ref,Inc_Array(slice->end));
  return (slice->p);
}

boolean Inc_Slice_Index(Slice *M(slicer))
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *tcrd  = slice->trg_ref->dims;
  Dimn_Type *bcrd  = slice->bcrd;
  Dimn_Type *ecrd  = slice->ecrd;
  Dimn_Type *cnt   = slice->acnt;
  int        ndims = slice->ndims;
  int        i, nclip, clip;
  
  clip  = slice->clip;
  nclip = -1;
  for (i = 0; i < ndims; i++)
    if (++cnt[i] == tcrd[i])
      { cnt[i] = 0;
        if (cnt[i] < bcrd[i])
          nclip = i;
        else if (clip == i)
          clip = -1;
      }
    else
      { if (cnt[i] > ecrd[i])
          nclip = i;
        else if (clip == i && cnt[i] >= bcrd[i])
          clip = -1;
        break;
      }
  if (nclip > clip)
    clip = nclip;
  slice->clip = clip;
  if (i >= ndims)
    slice->p = 0;
  else
    slice->p += 1;
  return (clip < 0);
}

boolean Dec_Slice_Index(Slice *M(slicer))
{ Slicer    *slice = (Slicer *) slicer;
  Dimn_Type *tcrd  = slice->trg_ref->dims;
  Dimn_Type *bcrd  = slice->bcrd;
  Dimn_Type *ecrd  = slice->ecrd;
  Dimn_Type *cnt   = slice->acnt;
  int        ndims = slice->ndims;
  int        i, nclip, clip;
  
  clip  = slice->clip;
  nclip = -1;
  for (i = 0; i < ndims; i++)
    if (cnt[i]-- == 0)
      { cnt[i] = tcrd[i]-1;
        if (cnt[i] > ecrd[i])
          nclip = i;
        else if (clip == i)
          clip = -1;
      }
    else
      { if (cnt[i] < bcrd[i])
          nclip = i;
        else if (clip == i && cnt[i] <= ecrd[i])
          clip = -1;
        break;
      }
  if (nclip > clip)
    clip = nclip;
  slice->clip = clip;
  if (i >= ndims)
    slice->p = slice->trg_ref->size-1;
  else
    slice->p -= 1;
  return (clip < 0);
}

Array *G(Make_Array_From_Slice)(Slice *slice)
{ Array *source = AForm_Array(slice);
  Array *target = Make_Array_With_Shape(PLAIN_KIND,source->type,AForm_Shape(slice));
  Size_Type n   = AForm_Size(slice);
  Indx_Type r, p;

  target->kind = AForm_Kind(slice);
  switch (source->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(source);
          uint8 *a = AUINT8(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(source);
          uint16 *a = AUINT16(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(source);
          uint32 *a = AUINT32(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(source);
          uint64 *a = AUINT64(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(source);
          int8 *a = AINT8(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(source);
          int16 *a = AINT16(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(source);
          int32 *a = AINT32(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(source);
          int64 *a = AINT64(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(source);
          float32 *a = AFLOAT32(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(source);
          float64 *a = AFLOAT64(target);

          for (r = 0, p = Set_Slice_To_First(slice); r < n; p = Next_Slice_Index(slice))
            a[r++] = d[p];
          break;
        }
  }

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  FRAME ITERATOR ROUTINES                                                             *
 *                                                                                      *
 ****************************************************************************************/

#define FRAME_KIND 5

typedef struct
  { Array_Kind  kind;     //  Always FRAME_KIND in order to distinguish from an Array
    Array      *trg_ref;  //  The array the frame is in.
    Coordinate *shape;    //  References to the shape and anchor coordinates defining frame
    Array      *anchor;

    Slice      *slice;    //  Frame's in-bound slice
    int         notempty; //  Frame can be in bounds (otherwise a fake slice and ignore in-status)

    int         ndims;    //  Dimensionality of the frame
    int64       size;     //  Size of the frame
    int64       vsize;    //  Size of value buffer

    Offs_Type  *offs;     //  Offset array of dimensions 'shape' that give offsets when within
    void       *vals;     //  Value array that holds frame values when not within
    int         mode;     //  Status of value array
  } Framer;

#define NOT_SET  0   //  Possible values for mode field
#define USE_VALS 1
#define USE_DBLS 2

static inline int64 framer_osize(Framer *f)
{ return (SIZEOF(int64)*f->size + SIZEOF(double)*f->vsize); }


typedef struct __Framer
  { struct __Framer *next;
    struct __Framer *prev;
    int              refcnt;
    int64           osize;
    Framer           framer;
  } _Framer;

static _Framer *Free_Framer_List = NULL;
static _Framer *Use_Framer_List  = NULL;

static pthread_mutex_t Framer_Mutex = PTHREAD_MUTEX_INITIALIZER;

static int Framer_Offset = sizeof(_Framer)-sizeof(Framer);
static int Framer_Inuse  = 0;

int Frame_Refcount(Frame *frame)
{ _Framer *object = (_Framer *) (((char *) frame) - Framer_Offset);
  return (object->refcnt);
}

static inline int allocate_framer_offs(Framer *framer, int64 osize, char *routine)
{ _Framer *object = (_Framer *) (((char *) framer) - Framer_Offset);
  if (object->osize < osize)
    { void *x = Guarded_Realloc(framer->offs,(size_t) osize,routine);
      if (x == NULL) return (1);
      framer->offs = x;
      object->osize = osize;
    }
  return (0);
}

static inline int64 sizeof_framer_offs(Framer *framer)
{ _Framer *object = (_Framer *) (((char *) framer) - Framer_Offset);
  return (object->osize);
}

static inline void kill_framer(Framer *framer);

static inline Framer *new_framer(int64 osize, char *routine)
{ _Framer *object;
  Framer  *framer;

  pthread_mutex_lock(&Framer_Mutex);
  if (Free_Framer_List == NULL)
    { object = (_Framer *) Guarded_Realloc(NULL,sizeof(_Framer),routine);
      if (object == NULL) return (NULL);
      framer = &(object->framer);
      object->osize = 0;
      framer->offs = NULL;
    }
  else
    { object = Free_Framer_List;
      Free_Framer_List = object->next;
      framer = &(object->framer);
    }
  Framer_Inuse += 1;
  object->refcnt = 1;
  if (Use_Framer_List != NULL)
    Use_Framer_List->prev = object;
  object->next = Use_Framer_List;
  object->prev = NULL;
  Use_Framer_List = object;
  pthread_mutex_unlock(&Framer_Mutex);
  framer->trg_ref = NULL;
  framer->shape = NULL;
  framer->anchor = NULL;
  framer->slice = NULL;
  if (allocate_framer_offs(framer,osize,routine))
    { kill_framer(framer);
      return (NULL);
    }
  return (framer);
}

static inline Framer *copy_framer(Framer *framer)
{ Framer *copy = new_framer(framer_osize(framer),"Copy_Frame");
  void *_offs = copy->offs;
  *copy = *framer;
  if (framer->trg_ref != NULL)
    Inc_Array(framer->trg_ref);
  if (framer->shape != NULL)
    copy->shape = Copy_Array(framer->shape);
  if (framer->anchor != NULL)
    copy->anchor = Copy_Array(framer->anchor);
  if (framer->slice != NULL)
    copy->slice = Copy_Slice(framer->slice);
  copy->offs = _offs;
  if (framer->offs != NULL)
    memcpy(copy->offs,framer->offs,(size_t) framer_osize(framer));
  return (copy);
}

Frame *Copy_Frame(Frame *frame)
{ return ((Frame *) copy_framer(((Framer *) frame))); }

static inline int pack_framer(Framer *framer)
{ _Framer *object  = (_Framer *) (((char *) framer) - Framer_Offset);
  if (framer->shape != NULL)
    if (Pack_Array(framer->shape) == NULL) return (1);
  if (framer->anchor != NULL)
    if (Pack_Array(framer->anchor) == NULL) return (1);
  if (framer->slice != NULL)
    if (Pack_Slice(framer->slice) == NULL) return (1);
  if (object->osize > framer_osize(framer))
    { int64 ns = framer_osize(framer);
      if (ns != 0)
        { void *x = Guarded_Realloc(framer->offs,(size_t) ns,"Pack_Framer");
          if (x == NULL) return (1);
          framer->offs = x;
        }
      else
        { free(framer->offs);
          framer->offs = NULL;
        }
      object->osize = ns;
    }
  return (0);
}

Frame *Inc_Frame(Frame *frame)
{ _Framer *object  = (_Framer *) (((char *) frame) - Framer_Offset);
  pthread_mutex_lock(&Framer_Mutex);
  object->refcnt += 1;
  pthread_mutex_unlock(&Framer_Mutex);
  return (frame);
}

static inline void free_framer(Framer *framer)
{ _Framer *object  = (_Framer *) (((char *) framer) - Framer_Offset);
  pthread_mutex_lock(&Framer_Mutex);
  if (--object->refcnt > 0)
    { pthread_mutex_unlock(&Framer_Mutex);
      return;
    }
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Freeing previously released Frame\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Framer_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  object->next = Free_Framer_List;
  Free_Framer_List = object;
  Framer_Inuse -= 1;
  pthread_mutex_unlock(&Framer_Mutex);
  if (framer->slice != NULL)
    { Free_Slice(framer->slice);
      framer->slice = NULL;
    }
  if (framer->anchor != NULL)
    { Free_Array(framer->anchor);
      framer->anchor = NULL;
    }
  if (framer->shape != NULL)
    { Free_Array(framer->shape);
      framer->shape = NULL;
    }
  if (framer->trg_ref != NULL)
    { Free_Array(framer->trg_ref);
      framer->trg_ref = NULL;
    }
}

void Free_Frame(Frame *frame)
{ free_framer(((Framer *) frame)); }

static inline void kill_framer(Framer *framer)
{ _Framer *object  = (_Framer *) (((char *) framer) - Framer_Offset);
  pthread_mutex_lock(&Framer_Mutex);
  if (--object->refcnt > 0)
    { pthread_mutex_unlock(&Framer_Mutex);
      return;
    }
  if (object->refcnt < 0)
    fprintf(stderr,"Warning: Killing previously released Frame\n");
  if (object->prev != NULL)
    object->prev->next = object->next;
  else
    Use_Framer_List = object->next;
  if (object->next != NULL)
    object->next->prev = object->prev;
  Framer_Inuse -= 1;
  pthread_mutex_unlock(&Framer_Mutex);
  if (framer->offs != NULL)
    free(framer->offs);
  if (framer->slice != NULL)
    Kill_Slice(framer->slice);
  if (framer->anchor != NULL)
    Kill_Array(framer->anchor);
  if (framer->shape != NULL)
    Kill_Array(framer->shape);
  if (framer->trg_ref != NULL)
    Kill_Array(framer->trg_ref);
  free(((char *) framer) - Framer_Offset);
}

void Kill_Frame(Frame *frame)
{ kill_framer(((Framer *) frame)); }

static inline void reset_framer()
{ _Framer *object;
  Framer  *framer;
  pthread_mutex_lock(&Framer_Mutex);
  while (Free_Framer_List != NULL)
    { object = Free_Framer_List;
      Free_Framer_List = object->next;
      framer = &(object->framer);
      if (framer->offs != NULL)
        free(framer->offs);
      free(object);
    }
  pthread_mutex_unlock(&Framer_Mutex);
}

void Reset_Frame()
{ reset_framer(); }

int Frame_Usage()
{ return (Framer_Inuse); }

void Frame_List(void (*handler)(Frame *))
{ _Framer *a, *b;
  for (a = Use_Framer_List; a != NULL; a = b)
    { b = a->next;
      handler((Frame *) &(a->framer));
    }
}

Frame *Pack_Frame(Frame *f)
{ Framer *o = (Frame *) f;
  boolean nok = pack_framer(o);
  o->vals = (void *) (o->offs + o->size);
  if (nok) return (NULL);
  return (f);
}

/****************************************************************************************
 *                                                                                      *
 *  OFFSET MAP AND BOUNDARY VALUE DETERMINATION ROUTINES                                *
 *                                                                                      *
 ****************************************************************************************/

typedef struct
  { Dimn_Type *ffdim;    //  Used by all
    Dimn_Type *fidim;    //  Used by all
    int32     *fctr;     //  Used by frame_offsets only
    int64     *fbcrd;    //  Remainder used by other routines
    int64     *fecrd;
    int64     *fdvol;
    void     **fibuf;
  } Frame_Args;

static Offs_Type *frame_offsets(int d, Offs_Type q, Offs_Type *o, Frame_Args *args)
{ Dimn_Type j;
  Dimn_Type n = args->ffdim[d];

  q = q*args->fidim[d] - args->fctr[d];
  if (d == 0)
    for (j = 0; j < n; j++)
      *o++ = q++;
  else
    for (j = 0; j < n; j++)
      o = frame_offsets(d-1,q++,o,args);
  return (o);
}

static inline int64 min_int64(int64 a, int64 b)
{ if (a < b)
    return (a);
  else
    return (b);
}


static uint8 *frame_zerod_uint8(int d, int64 size, uint8 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static uint8 *frame_zero_uint8(int d, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_uint8(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_uint8(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_uint8(d,e-j,o,args->ffdim);
    }
  return (o);
}

static uint8 *frame_wrap_uint8(int d, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_uint8(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_uint8(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_uint8(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint8 *frame_reflect_uint8(int d, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_uint8(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_uint8(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_uint8(d,q+k,o,a,args);
        }
    }
  return (o);
}

static uint8 *frame_extend_uint8(int d, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_uint8(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_uint8(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_uint8(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_uint8(int d, int64 q, int64 t, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint8) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint8) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (uint8) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((uint64) (x/2))*(ae-ab) + ae;
          else
            w = ((uint64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (uint8) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (uint8) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      uint8   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (uint8 *) args->fibuf[d];
      R = L + S;

      frame_invert_uint8(d,q,0,L,a,args);
      frame_invert_uint8(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_uint8(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint8) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_uint8(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint8) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_uint8(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_uint8(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint8) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_uint8(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint8) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static uint8 *expand_wrap_uint8(int d, int out, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_uint8(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_uint8(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_uint8(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint8 *expand_reflect_uint8(int d, int out, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint8(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_uint8(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint8(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static uint8 *expand_extend_uint8(int d, int out, int64 q, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_uint8(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_uint8(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_uint8(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_uint8(int d, int out, int64 q, int64 t, uint8 *o, uint8 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint8) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint8) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (uint8) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (uint8) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (uint8) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      uint8  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_uint8(d,out,q,t,o,a,args);
      expand_invert_uint8(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_uint8(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint8) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_uint8(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint8) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_uint8(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_uint8(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint8) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_uint8(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint8) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static uint16 *frame_zerod_uint16(int d, int64 size, uint16 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static uint16 *frame_zero_uint16(int d, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_uint16(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_uint16(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_uint16(d,e-j,o,args->ffdim);
    }
  return (o);
}

static uint16 *frame_wrap_uint16(int d, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_uint16(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_uint16(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_uint16(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint16 *frame_reflect_uint16(int d, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_uint16(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_uint16(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_uint16(d,q+k,o,a,args);
        }
    }
  return (o);
}

static uint16 *frame_extend_uint16(int d, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_uint16(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_uint16(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_uint16(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_uint16(int d, int64 q, int64 t, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint16) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint16) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (uint16) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((uint64) (x/2))*(ae-ab) + ae;
          else
            w = ((uint64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (uint16) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (uint16) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      uint16   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (uint16 *) args->fibuf[d];
      R = L + S;

      frame_invert_uint16(d,q,0,L,a,args);
      frame_invert_uint16(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_uint16(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint16) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_uint16(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint16) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_uint16(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_uint16(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint16) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_uint16(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint16) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static uint16 *expand_wrap_uint16(int d, int out, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_uint16(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_uint16(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_uint16(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint16 *expand_reflect_uint16(int d, int out, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint16(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_uint16(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint16(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static uint16 *expand_extend_uint16(int d, int out, int64 q, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_uint16(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_uint16(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_uint16(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_uint16(int d, int out, int64 q, int64 t, uint16 *o, uint16 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint16) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint16) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (uint16) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (uint16) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (uint16) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      uint16  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_uint16(d,out,q,t,o,a,args);
      expand_invert_uint16(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_uint16(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint16) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_uint16(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint16) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_uint16(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_uint16(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint16) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_uint16(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint16) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static uint32 *frame_zerod_uint32(int d, int64 size, uint32 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static uint32 *frame_zero_uint32(int d, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_uint32(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_uint32(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_uint32(d,e-j,o,args->ffdim);
    }
  return (o);
}

static uint32 *frame_wrap_uint32(int d, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_uint32(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_uint32(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_uint32(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint32 *frame_reflect_uint32(int d, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_uint32(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_uint32(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_uint32(d,q+k,o,a,args);
        }
    }
  return (o);
}

static uint32 *frame_extend_uint32(int d, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_uint32(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_uint32(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_uint32(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_uint32(int d, int64 q, int64 t, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint32) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint32) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (uint32) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((uint64) (x/2))*(ae-ab) + ae;
          else
            w = ((uint64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (uint32) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (uint32) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      uint32   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (uint32 *) args->fibuf[d];
      R = L + S;

      frame_invert_uint32(d,q,0,L,a,args);
      frame_invert_uint32(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_uint32(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_uint32(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_uint32(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_uint32(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_uint32(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static uint32 *expand_wrap_uint32(int d, int out, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_uint32(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_uint32(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_uint32(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint32 *expand_reflect_uint32(int d, int out, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint32(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_uint32(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint32(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static uint32 *expand_extend_uint32(int d, int out, int64 q, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_uint32(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_uint32(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_uint32(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_uint32(int d, int out, int64 q, int64 t, uint32 *o, uint32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint32) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint32) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (uint32) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (uint32) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (uint32) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      uint32  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_uint32(d,out,q,t,o,a,args);
      expand_invert_uint32(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_uint32(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_uint32(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_uint32(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_uint32(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint32) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_uint32(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint32) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static uint64 *frame_zerod_uint64(int d, int64 size, uint64 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static uint64 *frame_zero_uint64(int d, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_uint64(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_uint64(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_uint64(d,e-j,o,args->ffdim);
    }
  return (o);
}

static uint64 *frame_wrap_uint64(int d, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_uint64(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_uint64(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_uint64(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint64 *frame_reflect_uint64(int d, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_uint64(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_uint64(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_uint64(d,q+k,o,a,args);
        }
    }
  return (o);
}

static uint64 *frame_extend_uint64(int d, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_uint64(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_uint64(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_uint64(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_uint64(int d, int64 q, int64 t, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint64) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint64) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (uint64) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((uint64) (x/2))*(ae-ab) + ae;
          else
            w = ((uint64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (uint64) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (uint64) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      uint64   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (uint64 *) args->fibuf[d];
      R = L + S;

      frame_invert_uint64(d,q,0,L,a,args);
      frame_invert_uint64(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_uint64(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) + ((int64) F[y]));
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_uint64(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) - ((int64) F[y]));
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_uint64(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_uint64(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) + ((int64) F[y]));
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_uint64(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) - ((int64) F[y]));
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static uint64 *expand_wrap_uint64(int d, int out, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_uint64(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_uint64(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_uint64(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static uint64 *expand_reflect_uint64(int d, int out, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint64(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_uint64(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_uint64(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static uint64 *expand_extend_uint64(int d, int out, int64 q, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_uint64(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_uint64(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_uint64(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_uint64(int d, int out, int64 q, int64 t, uint64 *o, uint64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { uint64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((uint64) (x/2))*(ab - ae) + ab;
          else
            w = ((uint64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (uint64) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (uint64) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (uint64) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (uint64) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (uint64) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      uint64  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_uint64(d,out,q,t,o,a,args);
      expand_invert_uint64(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_uint64(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) + ((int64) F[y]));
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_uint64(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) - ((int64) F[y]));
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_uint64(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_uint64(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) + ((int64) F[y]));
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_uint64(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (uint64) (lx*((int64) L[y]) + rx*((int64) R[y]) - ((int64) F[y]));
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static int8 *frame_zerod_int8(int d, int64 size, int8 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static int8 *frame_zero_int8(int d, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_int8(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_int8(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_int8(d,e-j,o,args->ffdim);
    }
  return (o);
}

static int8 *frame_wrap_int8(int d, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_int8(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_int8(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_int8(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int8 *frame_reflect_int8(int d, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_int8(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_int8(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_int8(d,q+k,o,a,args);
        }
    }
  return (o);
}

static int8 *frame_extend_int8(int d, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_int8(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_int8(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_int8(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_int8(int d, int64 q, int64 t, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int8) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int8) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (int8) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((int64) (x/2))*(ae-ab) + ae;
          else
            w = ((int64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (int8) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (int8) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      int8   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (int8 *) args->fibuf[d];
      R = L + S;

      frame_invert_int8(d,q,0,L,a,args);
      frame_invert_int8(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_int8(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int8) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_int8(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int8) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_int8(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_int8(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int8) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_int8(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int8) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static int8 *expand_wrap_int8(int d, int out, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_int8(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_int8(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_int8(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int8 *expand_reflect_int8(int d, int out, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int8(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_int8(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int8(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static int8 *expand_extend_int8(int d, int out, int64 q, int8 *o, int8 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_int8(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_int8(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_int8(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_int8(int d, int out, int64 q, int64 t, int8 *o, int8 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int8) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int8) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (int8) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (int8) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (int8) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      int8  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_int8(d,out,q,t,o,a,args);
      expand_invert_int8(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_int8(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int8) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_int8(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int8) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_int8(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_int8(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int8) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_int8(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int8) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static int16 *frame_zerod_int16(int d, int64 size, int16 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static int16 *frame_zero_int16(int d, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_int16(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_int16(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_int16(d,e-j,o,args->ffdim);
    }
  return (o);
}

static int16 *frame_wrap_int16(int d, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_int16(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_int16(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_int16(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int16 *frame_reflect_int16(int d, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_int16(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_int16(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_int16(d,q+k,o,a,args);
        }
    }
  return (o);
}

static int16 *frame_extend_int16(int d, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_int16(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_int16(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_int16(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_int16(int d, int64 q, int64 t, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int16) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int16) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (int16) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((int64) (x/2))*(ae-ab) + ae;
          else
            w = ((int64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (int16) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (int16) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      int16   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (int16 *) args->fibuf[d];
      R = L + S;

      frame_invert_int16(d,q,0,L,a,args);
      frame_invert_int16(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_int16(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int16) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_int16(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int16) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_int16(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_int16(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int16) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_int16(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int16) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static int16 *expand_wrap_int16(int d, int out, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_int16(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_int16(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_int16(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int16 *expand_reflect_int16(int d, int out, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int16(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_int16(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int16(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static int16 *expand_extend_int16(int d, int out, int64 q, int16 *o, int16 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_int16(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_int16(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_int16(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_int16(int d, int out, int64 q, int64 t, int16 *o, int16 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int16) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int16) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (int16) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (int16) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (int16) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      int16  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_int16(d,out,q,t,o,a,args);
      expand_invert_int16(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_int16(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int16) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_int16(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int16) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_int16(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_int16(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int16) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_int16(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int16) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static int32 *frame_zerod_int32(int d, int64 size, int32 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static int32 *frame_zero_int32(int d, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_int32(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_int32(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_int32(d,e-j,o,args->ffdim);
    }
  return (o);
}

static int32 *frame_wrap_int32(int d, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_int32(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_int32(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_int32(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int32 *frame_reflect_int32(int d, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_int32(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_int32(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_int32(d,q+k,o,a,args);
        }
    }
  return (o);
}

static int32 *frame_extend_int32(int d, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_int32(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_int32(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_int32(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_int32(int d, int64 q, int64 t, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int32) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int32) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (int32) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((int64) (x/2))*(ae-ab) + ae;
          else
            w = ((int64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (int32) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (int32) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      int32   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (int32 *) args->fibuf[d];
      R = L + S;

      frame_invert_int32(d,q,0,L,a,args);
      frame_invert_int32(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_int32(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_int32(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_int32(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_int32(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_int32(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static int32 *expand_wrap_int32(int d, int out, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_int32(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_int32(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_int32(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int32 *expand_reflect_int32(int d, int out, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int32(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_int32(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int32(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static int32 *expand_extend_int32(int d, int out, int64 q, int32 *o, int32 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_int32(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_int32(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_int32(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_int32(int d, int out, int64 q, int64 t, int32 *o, int32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int32) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int32) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (int32) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (int32) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (int32) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      int32  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_int32(d,out,q,t,o,a,args);
      expand_invert_int32(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_int32(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_int32(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_int32(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_int32(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int32) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_int32(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int32) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static int64 *frame_zerod_int64(int d, int64 size, int64 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static int64 *frame_zero_int64(int d, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_int64(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_int64(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_int64(d,e-j,o,args->ffdim);
    }
  return (o);
}

static int64 *frame_wrap_int64(int d, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_int64(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_int64(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_int64(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int64 *frame_reflect_int64(int d, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_int64(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_int64(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_int64(d,q+k,o,a,args);
        }
    }
  return (o);
}

static int64 *frame_extend_int64(int d, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_int64(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_int64(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_int64(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_int64(int d, int64 q, int64 t, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int64) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int64) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (int64) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((int64) (x/2))*(ae-ab) + ae;
          else
            w = ((int64) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (int64) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (int64) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      int64   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (int64 *) args->fibuf[d];
      R = L + S;

      frame_invert_int64(d,q,0,L,a,args);
      frame_invert_int64(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_int64(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int64) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_int64(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int64) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_int64(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_int64(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int64) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_int64(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int64) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static int64 *expand_wrap_int64(int d, int out, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_int64(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_int64(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_int64(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static int64 *expand_reflect_int64(int d, int out, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int64(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_int64(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_int64(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static int64 *expand_extend_int64(int d, int out, int64 q, int64 *o, int64 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_int64(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_int64(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_int64(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_int64(int d, int out, int64 q, int64 t, int64 *o, int64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { int64   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((int64) (x/2))*(ab - ae) + ab;
          else
            w = ((int64) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (int64) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (int64) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (int64) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (int64) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (int64) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      int64  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_int64(d,out,q,t,o,a,args);
      expand_invert_int64(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_int64(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int64) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_int64(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (int64) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_int64(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_int64(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int64) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_int64(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (int64) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static float32 *frame_zerod_float32(int d, int64 size, float32 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static float32 *frame_zero_float32(int d, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_float32(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_float32(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_float32(d,e-j,o,args->ffdim);
    }
  return (o);
}

static float32 *frame_wrap_float32(int d, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_float32(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_float32(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_float32(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static float32 *frame_reflect_float32(int d, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_float32(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_float32(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_float32(d,q+k,o,a,args);
        }
    }
  return (o);
}

static float32 *frame_extend_float32(int d, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_float32(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_float32(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_float32(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_float32(int d, int64 q, int64 t, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { double   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((double) (x/2))*(ab - ae) + ab;
          else
            w = ((double) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (float32) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (float32) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (float32) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((double) (x/2))*(ae-ab) + ae;
          else
            w = ((double) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (float32) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (float32) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      float32   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (float32 *) args->fibuf[d];
      R = L + S;

      frame_invert_float32(d,q,0,L,a,args);
      frame_invert_float32(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_float32(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_float32(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_float32(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_float32(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_float32(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static float32 *expand_wrap_float32(int d, int out, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_float32(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_float32(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_float32(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static float32 *expand_reflect_float32(int d, int out, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_float32(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_float32(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_float32(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static float32 *expand_extend_float32(int d, int out, int64 q, float32 *o, float32 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_float32(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_float32(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_float32(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_float32(int d, int out, int64 q, int64 t, float32 *o, float32 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { double   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((double) (x/2))*(ab - ae) + ab;
          else
            w = ((double) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (float32) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (float32) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (float32) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (float32) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (float32) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      float32  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_float32(d,out,q,t,o,a,args);
      expand_invert_float32(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_float32(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float32) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_float32(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float32) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_float32(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_float32(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (float32) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_float32(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (float32) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}


static float64 *frame_zerod_float64(int d, int64 size, float64 *o, Dimn_Type *fdim)
{ while (d >= 0)
    size *= fdim[d--];
  while (size-- > 0)
    *o++ = 0;
  return (o);
}

static float64 *frame_zero_float64(int d, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = 0;
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j++ < e)
        *o++ = 0;
    }
  else
    { d -= 1;
      if (b < 0)
        { o = frame_zerod_float64(d,min_int64(0,e)-b,o,args->ffdim);
          if (e <= 0)
            return (o);
          j = 0;
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_zero_float64(d,q+j,o,a,args);
      if (e > f)
        o = frame_zerod_float64(d,e-j,o,args->ffdim);
    }
  return (o);
}

static float64 *frame_wrap_float64(int d, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            *o++ = a[q - (j % f)];
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          x  = m - min_int64(e,0);
          for (j = m-b; j > x; j--)
            o = frame_wrap_float64(d,q - (j%f),o,a,args);
          if (e <= 0)
            return (o);
          q -= m;
          j  = 0;
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_wrap_float64(d,q+j,o,a,args);
      while (j < e)
        o = frame_wrap_float64(d,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static float64 *frame_reflect_float64(int d, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  m  = ((f-1) << 1);
  if (d == 0)
    { if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              *o++ = a[q+k];
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      if (b < 0)
        { x = -min_int64(e,0);
          for (j = -b; j > x; j--)
            { k = j % m;
              if (k >= f)
                k = m-k;
              o = frame_reflect_float64(d,q+k,o,a,args);
            }
          if (e <= 0)
            return (o);
        }
      else
        j = b;
      for (x = min_int64(e,f); j < x; j++)
        o = frame_reflect_float64(d,q+j,o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = frame_reflect_float64(d,q+k,o,a,args);
        }
    }
  return (o);
}

static float64 *frame_extend_float64(int d, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q *= f;
  j  = b;
  if (d == 0)
    { if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            *o++ = a[q];
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        *o++ = a[q+j];
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      if (b < 0)
        { for (x = min_int64(0,e); j < x; j++)
            o = frame_extend_float64(d,q,o,a,args);
          if (e <= 0)
            return (o);
        }
      for (x = min_int64(e,f); j < x; j++)
        o = frame_extend_float64(d,q+j,o,a,args);
      q += f-1;
      while (j++ < e)
        o = frame_extend_float64(d,q,o,a,args);
    }
  return (o);
}

static void frame_invert_float64(int d, int64 q, int64 t, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->fidim[d];

  q  = q*f;
  t  = t*args->ffdim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { double   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((double) (x/2))*(ab - ae) + ab;
          else
            w = ((double) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (float64) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (float64) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        *o++ = (float64) a[j];

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            w = ((double) (x/2))*(ae-ab) + ae;
          else
            w = ((double) (x/2))*(ae-ab);
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { *o++ = (float64) (w + a[m-k]);
                if (k < f)
                  w += ae;
              }
            else
              { *o++ = (float64) (w - a[k]);
                if (k == 0)
                  { w -= ab;
                    k  = m;
                  }
              }
        }
    }

  else
    { int64 lx, rx, y, S;
      float64   *L, *R, *F;

      d -= 1;
      t -= b;

      S = args->fdvol[d];
      F = o;
      L = (float64 *) args->fibuf[d];
      R = L + S;

      frame_invert_float64(d,q,0,L,a,args);
      frame_invert_float64(d,q+(f-1),0,R,a,args);

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = o + (t+b)*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { frame_invert_float64(d,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float64) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { frame_invert_float64(d,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float64) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (x = min_int64(e,f); j < x; j++)
        frame_invert_float64(d,q + j,t + j,o,a,args);

      if (j < e)
        { x = (j-f)/(f-1) + 1;
          if (x % 2)
            { rx = x+1;
              lx = -(x-1);
            }
          else
            { rx = x;
              lx = -x;
            }
          F = o + (t+j)*S;
          for (k = m - (j-1) % m; j < e; j++)
            if (k-- >= f)
              { frame_invert_float64(d,q + (m-k),t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float64) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k < f)
                  rx += 2;
              }
            else
              { frame_invert_float64(d,q + k,t + j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float64) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k == 0)
                  { lx -= 2;
                    k   = m;
                  }
              }
        }
    }
}

/****************************************************************************************
 *                                                                                      *
 *  BOUNDARY VALUE FILLING FOR EXPANSION (related to frame routines but subroutines     *
 *    of Pad_Array and Pad_Array_Inplace)                                               *
 *                                                                                      *
 ****************************************************************************************/

static float64 *expand_wrap_float64(int d, int out, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, m;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            *o++ = a[q - (j % f)];
          q -= m;
        }
      if (out)
        for (j = 0; j < f; j++)
          *o++ = a[q+j];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        *o++ = a[q + ((j++) % f)];
    }
  else
    { d -= 1;
      if (b < 0)
        { m  = f-1;
          q += m;
          for (j = m-b; j > m; j--)
            o = expand_wrap_float64(d,1,q - (j%f),o,a,args);
          q -= m;
        }
      for (j = 0; j < f; j++)
        o = expand_wrap_float64(d,out,q+j,o,a,args);
      while (j < e)
        o = expand_wrap_float64(d,1,q + ((j++) % f),o,a,args);
    }
  return (o);
}

static float64 *expand_reflect_float64(int d, int out, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, m, k;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  m  = ((f-1) << 1);
  if (d == 0)
    { for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          *o++ = a[q+k];
        }
    }
  else
    { d -= 1;
      for (j = -b; j > 0; j--)
        { k = j % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_float64(d,1,q+k,o,a,args);
        }
      while (j < f)
        o = expand_reflect_float64(d,out,q+(j++),o,a,args);
      while (j < e)
        { k = (j++) % m;
          if (k >= f)
            k = m-k;
          o = expand_reflect_float64(d,1,q+k,o,a,args);
        }
    }
  return (o);
}

static float64 *expand_extend_float64(int d, int out, int64 q, float64 *o, float64 *a, Frame_Args *args)
{ int64 j;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q = q*args->fidim[d] - b;
  if (d == 0)
    { for (j = b; j < 0; j++)
        *o++ = a[q];
      if (out)
        while (j < f)
          *o++ = a[q+(j++)];
      else
        { o += f;
          j = f;
        }
      q += f-1;
      while (j++ < e)
        *o++ = a[q];
    }
  else
    { d -= 1;
      for (j = b; j < 0; j++)
        o = expand_extend_float64(d,1,q,o,a,args);
      while (j < f)
        o = expand_extend_float64(d,out,q+(j++),o,a,args);
      q += f-1;
      while (j++ < e)
        o = expand_extend_float64(d,1,q,o,a,args);
    }
  return (o);
}

static void expand_invert_float64(int d, int out, int64 q, int64 t, float64 *o, float64 *a, Frame_Args *args)
{ int64 j, k, m, x;
  int64 e = args->fecrd[d];
  int64 b = args->fbcrd[d];
  int64 f = args->ffdim[d];

  q  = q*args->fidim[d] - b;
  t  = t*args->fidim[d];
  m  = ((f-1) << 1);

  if (d == 0)
    { double   w, ab, ae;

      a += q;
      o += t;
      ab = 2*a[0];
      ae = 2*a[f-1];

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            w = ((double) (x/2))*(ab - ae) + ab;
          else
            w = ((double) (x/2))*(ab - ae);
          x = -min_int64(e,0);
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { *o++ = (float64) (w + a[m-k]);
                if (k-- == f)
                  w += ae;
              }
            else
              { *o++ = (float64) (w - a[k]);
                if (k-- == 1)
                  { w -= ab;
                    k  = m;
                  }
              }
          if (e <= 0)
            return;
        }

      if (out)
        for (x = min_int64(e,f); j < x; j++)
          *o++ = (float64) a[j];
      else
        { o += f;
          j  = f;
        }

      w = ae;
      for (k = f-1; j < e; j++)
        if (k-- >= f)
          { *o++ = (float64) (w + a[m-k]);
            if (k < f)
              w += ae;
          }
        else
          { *o++ = (float64) (w - a[k]);
            if (k == 0)
              { w -= ab;
                k  = m;
              }
          }
    }

  else
    { int64 lx, rx, y, S;
      float64  *L, *R, *F;

      d -= 1;
      t -= b;

      expand_invert_float64(d,out,q,t,o,a,args);
      expand_invert_float64(d,out,q+(f-1),t+(f-1),o,a,args);

      S = args->fdvol[d];
      L = o + t*S;
      R = o + (t+(f-1))*S;

      j = b;
      if (b < 0)
        { j  = -b;
          x  = (j-1)/(f-1)+1;
          if (x % 2)
            { lx = x+1;
              rx = -(x-1);
            }
          else
            { lx = x;
              rx = -x;
            }
          x = -min_int64(e,0);
          F = L + b*S;
          for (k = (j-1) % m + 1; j > x; j--)
            if (k >= f)
              { expand_invert_float64(d,1,q + (m-k),t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float64) (lx*L[y] + rx*R[y] + F[y]);
                F += S;

                if (k-- == f)
                  rx += 2;
              }
            else
              { expand_invert_float64(d,1,q + k,t - j,o,a,args);

                for (y = 0; y < S; y++)
                  F[y] = (float64) (lx*L[y] + rx*R[y] - F[y]);
                F += S;

                if (k-- == 1)
                  { lx -= 2;
                    k   = m;
                  }
              }
          if (e <= 0)
            return;
        }

      for (j = 1; j < f-1; j++)
        expand_invert_float64(d,out,q + j,t + j,o,a,args);

      rx = 2;
      lx = 0;
      F  = R + S;
      k  = f-1;
      for (j = f; j < e; j++)
        if (k-- >= f)
          { expand_invert_float64(d,1,q + (m-k),t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (float64) (lx*L[y] + rx*R[y] + F[y]);
            F += S;

            if (k < f)
              rx += 2;
          }
        else
          { expand_invert_float64(d,1,q + k,t + j,o,a,args);

            for (y = 0; y < S; y++)
              F[y] = (float64) (lx*L[y] + rx*R[y] - F[y]);
            F += S;

            if (k == 0)
              { lx -= 2;
                k   = m;
              }
          }
    }
}



/****************************************************************************************
 *                                                                                      *
 *  FRAME CORE ROUTINES                                                                 *
 *                                                                                      *
 ****************************************************************************************/

Frame *G(Make_Frame)(Array *I(target), Coordinate *S(shape), Coordinate *S(anchor))
{ Framer    *frame;
  Dimn_Type *scrd = ADIMN(shape);
  int32     *ccrd = AINT32(anchor);
  int        i, ndims;
  Size_Type  size, vsize;

  if (shape->ndims != 1 || shape->type != DIMN_TYPE)
    { fprintf(stderr,"Shape is not a coordinate vector (Make_Frame)\n");
      exit (1);
    }
  if (anchor->ndims != 1 || anchor->type != DIMN_TYPE)
    { fprintf(stderr,"Center is not an integer vector (Make_Frame)\n");
      exit (1);
    }
  if (Array_Refcount(shape) != 1)
    { fprintf(stderr,"Shape is not subsumable, has a reference count > 1 (Make_Frame)\n");
      exit (1);
    }
  if (Array_Refcount(anchor) != 1)
    { fprintf(stderr,"Center is not subsumable, has a reference count > 1 (Make_Frame)\n");
      exit (1);
    }

  ndims = (int) shape->size;
  if (target->ndims != ndims && (target->ndims-1 != ndims || target->kind == PLAIN_KIND))
    { fprintf(stderr,"Target and coordinate dimensionality do not match (Make_Frame)\n");
      exit (1);
    }
  if (anchor->size != ndims)
    { fprintf(stderr,"Shape and anchor coordinate dimensionality do not match (Make_Frame)\n");
      exit (1);
    }

  if (ndims == target->ndims-1)
    { ndims += 1;
      if (target->kind == COMPLEX_KIND)
        { PrependCoord(shape,2);
          PrependCoord(anchor,0);
        }
      else
        { AppendCoord(kind_size[target->kind],shape);
          AppendCoord(0,anchor);
        }
      scrd = ADIMN(shape);
      ccrd = AINT32(anchor);
    }

  size  = 1;
  vsize = 0;
  for (i = 0; i < ndims; i++)
    { vsize += 2*size;
      size  *= scrd[i];
    }
  vsize += size-2;

  frame = new_framer(size*SIZEOF(Offs_Type)+vsize*SIZEOF(double),"Make_Frame");

  frame->kind    = FRAME_KIND;
  frame->trg_ref = Inc_Array(target);
  frame->shape   = shape;
  frame->anchor  = anchor;

  frame->ndims = ndims;
  frame->size  = size;
  frame->vsize = vsize;

  { Coordinate *low = Copy_Array(shape);
    Coordinate *hgh = Copy_Array(shape);
    Dimn_Type *hcrd = ADIMN(hgh);
    Dimn_Type *lcrd = ADIMN(low);

    frame->notempty = 1;
    for (i = 0; i < ndims; i++)
      { if (ccrd[i] < 0)
          { if (scrd[i] + ccrd[i] > target->dims[i])
              frame->notempty = 0;
          }
        else if (ccrd[i] < scrd[i])
          { if (scrd[i] > target->dims[i])
              frame->notempty = 0;
          }
        else // ccrd[i] >= scrd[i]
          { if (ccrd[i] >= target->dims[i])
              frame->notempty = 0;
          }
        if (frame->notempty)
          { if (ccrd[i] < 0)
              lcrd[i] = 0;
            else
              lcrd[i] = ccrd[i];
            if (ccrd[i] >= scrd[i])
              hcrd[i] = target->dims[i]-1;
            else
              hcrd[i] = target->dims[i] + ccrd[i] - scrd[i];
          }
        else
          lcrd[i] = hcrd[i] = 0;
        if ( ! frame->notempty)
          lcrd[i] = hcrd[i] = 0;
      }

    frame->slice = Make_Slice(target,low,hgh);
  }

  frame->vals = (void *) (frame->offs + size);

  { Frame_Args args;

    args.fctr  = ccrd;
    args.ffdim = scrd;
    args.fidim = target->dims;
    frame_offsets(ndims-1,0,frame->offs,&args);
  }

  frame->mode = NOT_SET;
  Set_Slice_To_Index(frame->slice,0);

  return ((Frame *) frame);
}

#define FRAME(f)            ((Framer *) f)
#define FRAME_SLICE(f)      (FRAME(f)->slice)
#define FRAME_INDEX(f)      (((Slicer *) FRAME_SLICE(f))->p)
#define FRAME_COORDINATE(f) (((Slicer *) FRAME_SLICE(f))->cnt)
#define FRAME_WITHIN(f)     (((Slicer *) FRAME_SLICE(f))->clip < 0 && FRAME(f)->notempty)

Coordinate *Frame_Shape(Frame *frame)
{ return (FRAME(frame)->shape); }

Coordinate *Frame_Anchor(Frame *frame)
{ return (FRAME(frame)->anchor); }

Indx_Type Frame_Index(Frame *frame)
{ return (FRAME_INDEX(frame));  }

Coordinate *Frame_Coordinate(Frame *frame)
{ return (FRAME_COORDINATE(frame));  }

boolean Place_Frame(Frame *M(frame), Indx_Type p)
{ FRAME(frame)->mode = NOT_SET;
  return (Set_Slice_To_Index(FRAME_SLICE(frame),p) && FRAME(frame)->notempty);
}

boolean Move_Frame_Forward(Frame *M(frame))
{ FRAME(frame)->mode = NOT_SET;
  return (Inc_Slice_Index(FRAME_SLICE(frame)) && FRAME(frame)->notempty);
}

boolean Move_Frame_Backward(Frame *M(frame))
{ FRAME(frame)->mode = NOT_SET;
  return (Dec_Slice_Index(FRAME_SLICE(frame)) && FRAME(frame)->notempty);
}

boolean Frame_Within_Array(Frame *frame)
{ return (FRAME_WITHIN(frame)); }

static void setup_value_compute(Framer *frame)
{ int ndims = frame->ndims;

  if (FRAME_WITHIN(frame))
    { Size_Type  n = frame->size;
      Offs_Type *o = frame->offs;
      Indx_Type j;

      switch (frame->trg_ref->type) {
          case UINT8_TYPE:
            { uint8 *v = AUINT8(frame->trg_ref) + FRAME_INDEX(frame);
              uint8 *d = (uint8 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case UINT16_TYPE:
            { uint16 *v = AUINT16(frame->trg_ref) + FRAME_INDEX(frame);
              uint16 *d = (uint16 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case UINT32_TYPE:
            { uint32 *v = AUINT32(frame->trg_ref) + FRAME_INDEX(frame);
              uint32 *d = (uint32 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case UINT64_TYPE:
            { uint64 *v = AUINT64(frame->trg_ref) + FRAME_INDEX(frame);
              uint64 *d = (uint64 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case INT8_TYPE:
            { int8 *v = AINT8(frame->trg_ref) + FRAME_INDEX(frame);
              int8 *d = (int8 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case INT16_TYPE:
            { int16 *v = AINT16(frame->trg_ref) + FRAME_INDEX(frame);
              int16 *d = (int16 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case INT32_TYPE:
            { int32 *v = AINT32(frame->trg_ref) + FRAME_INDEX(frame);
              int32 *d = (int32 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case INT64_TYPE:
            { int64 *v = AINT64(frame->trg_ref) + FRAME_INDEX(frame);
              int64 *d = (int64 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case FLOAT32_TYPE:
            { float32 *v = AFLOAT32(frame->trg_ref) + FRAME_INDEX(frame);
              float32 *d = (float32 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
          case FLOAT64_TYPE:
            { float64 *v = AFLOAT64(frame->trg_ref) + FRAME_INDEX(frame);
              float64 *d = (float64 *) frame->vals;
              for (j = 0; j < n; j++)
                d[j] = v[o[j]];
              break;
            }
      }
    }

  else
    { Dimn_Type *pos = ADIMN(FRAME_COORDINATE(frame));
      int32     *low = AINT32(frame->anchor);
      Dimn_Type *hgh = ADIMN(frame->shape);

      int64 Fbcrd[10], *bcrd;
      int64 Fecrd[10], *ecrd;
      int64 Fdvol[10], *dvol;
      void *Fibuf[10], **ibuf;

      Frame_Args args;

      if (ndims > 10)
        { bcrd = (int64 *) Guarded_Malloc(sizeof(int64)*4*((size_t) ndims),"Frame_Offsets");
          ecrd = bcrd + ndims;
          dvol = ecrd + ndims;
          ibuf = (void **) (dvol + ndims);
        }
      else
        { bcrd = Fbcrd;
          ecrd = Fecrd;
          dvol = Fdvol;
          ibuf = Fibuf;
        }

      { int64 i, b;

        for (i = 0; i < ndims; i++)
          { bcrd[i] = b = ((int64) pos[i]) - low[i];
            ecrd[i] = b + hgh[i];
          }
      }

      args.fbcrd = bcrd;
      args.fecrd = ecrd;
      args.fidim = frame->trg_ref->dims;
      args.ffdim = hgh;

      switch (frame->trg_ref->type) {
          case UINT8_TYPE:
            { uint8 *a = AUINT8(frame->trg_ref);
              uint8 *o = (uint8 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_uint8(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_uint8(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_uint8(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_uint8(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_uint8(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case UINT16_TYPE:
            { uint16 *a = AUINT16(frame->trg_ref);
              uint16 *o = (uint16 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_uint16(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_uint16(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_uint16(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_uint16(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_uint16(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case UINT32_TYPE:
            { uint32 *a = AUINT32(frame->trg_ref);
              uint32 *o = (uint32 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_uint32(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_uint32(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_uint32(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_uint32(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_uint32(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case UINT64_TYPE:
            { uint64 *a = AUINT64(frame->trg_ref);
              uint64 *o = (uint64 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_uint64(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_uint64(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_uint64(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_uint64(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_uint64(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case INT8_TYPE:
            { int8 *a = AINT8(frame->trg_ref);
              int8 *o = (int8 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_int8(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_int8(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_int8(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_int8(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_int8(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case INT16_TYPE:
            { int16 *a = AINT16(frame->trg_ref);
              int16 *o = (int16 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_int16(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_int16(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_int16(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_int16(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_int16(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case INT32_TYPE:
            { int32 *a = AINT32(frame->trg_ref);
              int32 *o = (int32 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_int32(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_int32(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_int32(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_int32(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_int32(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case INT64_TYPE:
            { int64 *a = AINT64(frame->trg_ref);
              int64 *o = (int64 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_int64(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_int64(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_int64(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_int64(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_int64(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *a = AFLOAT32(frame->trg_ref);
              float32 *o = (float32 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_float32(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_float32(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_float32(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_float32(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_float32(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *a = AFLOAT64(frame->trg_ref);
              float64 *o = (float64 *) frame->vals;
              switch (Boundary_Case_8qm5)
              { case BND_ZERO:
                  frame_zero_float64(ndims-1,0,o,a,&args);
                  break;
                case BND_REFLECT:
                  frame_reflect_float64(ndims-1,0,o,a,&args);
                  break;
                case BND_WRAP:
                  frame_wrap_float64(ndims-1,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  frame_extend_float64(ndims-1,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 b, v;
                    int   i;

                    b = 1;
                    v = frame->size;
                    for (i = 0; i < ndims; i++)
                      { ibuf[i] = o + v;
                        b *= hgh[i];
                        v += 2*b;
                        dvol[i] = b;
                      }
                    args.fibuf = ibuf;
                    args.fdvol = dvol;
                    frame_invert_float64(ndims-1,0,0,o,a,&args);
                    break;
                  }
              }
              break;
            }
      }

      if (ndims > 10)
        free(bcrd);
    }

  frame->mode = USE_VALS;
}

void *Frame_Values(Frame *framer)
{ Framer *frame = (Framer *) framer;
  if (frame->mode != USE_VALS)
    setup_value_compute(frame);
  return ((void *) (frame->vals));
}

Offs_Type *Frame_Offsets(Frame *f)
{ return (FRAME(f)->offs); }

Array_Bundle *Frame_Array(Array_Bundle *R(O(a)), Frame *framer)
{ static char text[1] = { '\0' };
  Framer *frame = (Framer *) framer;
  a->type   = frame->trg_ref->type;
  a->ndims  = frame->trg_ref->ndims;
  a->dims   = ADIMN(frame->shape);
  a->size   = frame->size;
  a->tlen   = 0;
  a->text   = text;
  a->data   = Frame_Values(framer);
  a->scale  = frame->trg_ref->scale;
  a->kind   = AForm_Kind(frame);
  return (a);
}

Array *G(Make_Array_From_Frame)(Frame *framer)
{ Framer *frame = (Framer *) framer;
  Array  *a     = frame->trg_ref;
  
  Array  *target = Make_Array(PLAIN_KIND,a->type,a->ndims,ADIMN(frame->shape));

  target->kind = AForm_Kind(frame);

  { Size_Type n = target->size;
    Indx_Type j;

    if (FRAME_WITHIN(frame))
      { Offs_Type *o = frame->offs;
        switch (a->type) {
            case UINT8_TYPE:
              { uint8 *d = AUINT8(target);
                uint8 *v = AUINT8(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case UINT16_TYPE:
              { uint16 *d = AUINT16(target);
                uint16 *v = AUINT16(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case UINT32_TYPE:
              { uint32 *d = AUINT32(target);
                uint32 *v = AUINT32(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case UINT64_TYPE:
              { uint64 *d = AUINT64(target);
                uint64 *v = AUINT64(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case INT8_TYPE:
              { int8 *d = AINT8(target);
                int8 *v = AINT8(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case INT16_TYPE:
              { int16 *d = AINT16(target);
                int16 *v = AINT16(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case INT32_TYPE:
              { int32 *d = AINT32(target);
                int32 *v = AINT32(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case INT64_TYPE:
              { int64 *d = AINT64(target);
                int64 *v = AINT64(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case FLOAT32_TYPE:
              { float32 *d = AFLOAT32(target);
                float32 *v = AFLOAT32(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
            case FLOAT64_TYPE:
              { float64 *d = AFLOAT64(target);
                float64 *v = AFLOAT64(frame->trg_ref) + FRAME_INDEX(frame);
                for (j = 0; j < n; j++)
                  d[j] = v[o[j]];
                break;
              }
        }
      }
    else
      { if (frame->mode == NOT_SET)
          setup_value_compute(frame);
        switch (a->type) {
            case UINT8_TYPE:
              { uint8 *d = AUINT8(target);
                uint8 *v = (uint8 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case UINT16_TYPE:
              { uint16 *d = AUINT16(target);
                uint16 *v = (uint16 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case UINT32_TYPE:
              { uint32 *d = AUINT32(target);
                uint32 *v = (uint32 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case UINT64_TYPE:
              { uint64 *d = AUINT64(target);
                uint64 *v = (uint64 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case INT8_TYPE:
              { int8 *d = AINT8(target);
                int8 *v = (int8 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case INT16_TYPE:
              { int16 *d = AINT16(target);
                int16 *v = (int16 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case INT32_TYPE:
              { int32 *d = AINT32(target);
                int32 *v = (int32 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case INT64_TYPE:
              { int64 *d = AINT64(target);
                int64 *v = (int64 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case FLOAT32_TYPE:
              { float32 *d = AFLOAT32(target);
                float32 *v = (float32 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
            case FLOAT64_TYPE:
              { float64 *d = AFLOAT64(target);
                float64 *v = (float64 *) frame->vals;
                for (j = 0; j < n; j++)
                  d[j] = v[j];
                break;
              }
        }
      }
  }

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY FORM BASICS                                                                   *
 *                                                                                      *
 ****************************************************************************************/

static Form_Class _AForm_Class[] = { ARRAY_CLASS, ARRAY_CLASS, ARRAY_CLASS,
                                     ARRAY_CLASS, SLICE_CLASS, FRAME_CLASS };

Form_Class AForm_Class(AForm *form)
{ return (_AForm_Class[((Array *) form)->kind]); }

boolean Is_Slice(AForm *o)
{ return (((Array *) o)->kind == SLICE_KIND); }

boolean Is_Frame(AForm *o)
{ return (((Array *) o)->kind == FRAME_KIND); }

boolean Is_Array(AForm *o)
{ return (((Array *) o)->kind <= COMPLEX_KIND); }

Array *AForm_Array(AForm *form)
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return (((Slicer *) form)->trg_ref);
    case FRAME_CLASS:
      return (((Framer *) form)->trg_ref);
    case ARRAY_CLASS:
      return ((Array *) form);
  }
  return (NULL);
}

Size_Type AForm_Size(AForm *form)
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return (((Slicer *) form)->size);
    case FRAME_CLASS:
      return (((Framer *) form)->size);
    case ARRAY_CLASS:
    default:
      return (((Array *) form)->size);
  }
}

Array_Kind AForm_Kind(AForm *form)
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      { Slicer    *slice = (Slicer *) form;
        int        ndims = slice->ndims;
        Array_Kind kind  = slice->trg_ref->kind;
        if (kind == RGB_KIND || kind == RGBA_KIND)
          { if (slice->bcrd[ndims-1] != 0 || slice->ecrd[ndims-1] != kind_size[kind]-1)
              kind = PLAIN_KIND;
          }
        else if (kind == COMPLEX_KIND)
          { if (slice->bcrd[0] != 0 || slice->ecrd[0] != 1)
              kind = PLAIN_KIND;
          }
        return (kind);
      }
    case FRAME_CLASS:
      { Framer    *frame = (Framer *) form;
        int        ndims = frame->ndims;
        Array_Kind kind  = frame->trg_ref->kind;
        if (kind == RGB_KIND || kind == RGBA_KIND)
          { if (ADIMN(frame->shape)[ndims-1] != kind_size[kind])
              kind = PLAIN_KIND;
          }
        else if (kind == COMPLEX_KIND)
          { if (ADIMN(frame->shape)[0] != 2)
              kind = PLAIN_KIND;
          }
        return (kind);
      }
    case ARRAY_CLASS:
      return (((Array *) form)->kind);
  }
  return (PLAIN_KIND);
}

Coordinate *G(AForm_Shape)(AForm *form)
{ Coordinate *coord;

  switch (AForm_Class(form))
  { case SLICE_CLASS:
      { Slicer     *slice = (Slicer *) form;
        Dimn_Type  *bcrd, *bval;
        int         i;

        coord = Copy_Array(slice->end);
        bval  = ADIMN(coord);
        bcrd  = slice->bcrd;
        for (i = 0; i < slice->ndims; i++)
          bval[i] = (bval[i] - bcrd[i]) + 1;
        return (coord);
      }
    case FRAME_CLASS:
      return (Copy_Array(Frame_Shape((Frame *) form)));
    case ARRAY_CLASS:
      { Array *a = (Array *) form;
        coord = Make_Array_With_Shape(PLAIN_KIND,DIMN_TYPE,Coord1(a->ndims));
        memcpy(ADIMN(coord),a->dims,sizeof(Dimn_Type)*((size_t) a->ndims));
        return (coord);
      }
  }
  return (NULL);
}

Array *G(Make_Array_From_AForm)(AForm *form)
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return (Make_Array_From_Slice((Slice *) form));
    case FRAME_CLASS:
      return (Make_Array_From_Frame((Frame *) form));
    case ARRAY_CLASS:
      return (Copy_Array((Array *) form));
  }
  return (NULL);
}

AForm *G(Copy_AForm)(AForm *form)
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return ((AForm *) Copy_Slice((Slice *) form));
    case FRAME_CLASS:
      return ((AForm *) Copy_Frame((Frame *) form));
    case ARRAY_CLASS:
      return ((AForm *) Copy_Array((Array *) form));
  }
  return (NULL);
}

AForm *Pack_AForm(AForm *R(M(form)))
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return ((AForm *) Pack_Slice((Slice *) form));
    case FRAME_CLASS:
      return ((AForm *) Pack_Frame((Frame *) form));
    case ARRAY_CLASS:
      return ((AForm *) Pack_Array((Array *) form));
  }
  return (NULL);
}

AForm *Inc_AForm(AForm *R(I(form)))
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return ((AForm *) Inc_Slice((Slice *) form));
    case FRAME_CLASS:
      return ((AForm *) Inc_Frame((Frame *) form));
    case ARRAY_CLASS:
      return ((AForm *) Inc_Array((Array *) form));
  }
  return (NULL);
}

void Free_AForm(AForm *F(form))
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      Free_Slice((Slice *) form);
      return;
    case FRAME_CLASS:
      Free_Frame((Frame *) form);
      return;
    case ARRAY_CLASS:
      Free_Array((Array *) form);
      return;
  }
}

void Kill_AForm(AForm *K(form))
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      Kill_Slice((Slice *) form);
      return;
    case FRAME_CLASS:
      Kill_Frame((Frame *) form);
      return;
    case ARRAY_CLASS:
      Kill_Array((Array *) form);
      return;
  }
}

void Reset_AForm()
{ Reset_Array();
  Reset_Slice();
  Reset_Frame();
}

int AForm_Usage()
{ return (Array_Usage()+Slice_Usage()+Frame_Usage()); }

void AForm_List(void (*handler)(AForm *))
{ void (*ahandler)(Array *) = (void (*)(Array *)) handler;
  Array_List(ahandler);
  Slice_List(handler);
  Frame_List(handler);
}

int AForm_Refcount(AForm *form)
{ switch (AForm_Class(form))
  { case SLICE_CLASS:
      return (Slice_Refcount((Slice *) form));
    case FRAME_CLASS:
      return (Frame_Refcount((Frame *) form));
    case ARRAY_CLASS:
      return (Array_Refcount((Array *) form));
  }
  return (0);
}

/****************************************************************************************
 *                                                                                      *
 *  DISPLAY AN ARRAY                                                                    *
 *                                                                                      *
 ****************************************************************************************/

static string type_name[] = { "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32",
                              "int64", "float32", "float64" };

static int   Uindent;
static FILE *Uoutput;

static void Uhandler(Array *a)
{ int       i;
  Size_Type bytes;

  fprintf(Uoutput,"%*s%2d : %u",Uindent,"",Array_Refcount(a),a->dims[a->ndims-1]);
  for (i = a->ndims-2; i >= 0; i--)
    fprintf(Uoutput," x %u",a->dims[i]);
  fprintf(Uoutput," %s",type_name[a->type]);
  bytes = a->size * type_size[a->type];
  if (bytes < 1.e3)
    fprintf(Uoutput," = %llu",bytes);
  else if (bytes < 1.e6)
    fprintf(Uoutput," = %.1fKb",bytes/1.e3);
  else if (bytes < 1.e9)
    fprintf(Uoutput," = %.1fMb",bytes/1.e6);
  else 
    fprintf(Uoutput," = %.2fGb",bytes/1.e9);
  if (a->text != NULL && a->text[0] != '\0')
    fprintf(Uoutput," : '%.*s'",50,a->text);
  fprintf(Uoutput,"\n");
}

static void Shandler(Slice *s)
{ int        i;
  Dimn_Type *scrd;
  Array     *a = AForm_Array(s);

  scrd = ADIMN(Slice_First(s));
  fprintf(Uoutput,"%*s%2d : (%u",Uindent,"",Slice_Refcount(a),scrd[a->ndims-1]);
  for (i = a->ndims-2; i >= 0; i--)
    fprintf(Uoutput,",%u",scrd[i]);
  scrd = ADIMN(Slice_Last(s));
  fprintf(Uoutput,") - (%u",scrd[a->ndims-1]);
  for (i = a->ndims-2; i >= 0; i--)
    fprintf(Uoutput,",%u",scrd[i]);
  fprintf(Uoutput,") %s",type_name[a->type]);
  if (a->text != NULL && a->text[0] != '\0')
    fprintf(Uoutput," @ '%.*s'",50,a->text);
  fprintf(Uoutput,"\n");
}

static void Fhandler(Frame *f)
{ int        i;
  Size_Type  bytes;
  Dimn_Type *scrd;
  Array     *a = AForm_Array(f);

  scrd = ADIMN(Frame_Shape(f));
  fprintf(Uoutput,"%*s%2d : %u",Uindent,"",Frame_Refcount(f),scrd[a->ndims-1]);
  for (i = a->ndims-2; i >= 0; i--)
    fprintf(Uoutput," x %u",scrd[i]);
  fprintf(Uoutput," %s",type_name[a->type]);
  bytes = AForm_Size(f) * 24;
  if (bytes < 1.e3)
    fprintf(Uoutput," = %llu",bytes);
  else if (bytes < 1.e6)
    fprintf(Uoutput," = %.1fKb",bytes/1.e3);
  else if (bytes < 1.e9)
    fprintf(Uoutput," = %.1fMb",bytes/1.e6);
  else 
    fprintf(Uoutput," = %.2fGb",bytes/1.e9);
  if (a->text != NULL && a->text[0] != '\0')
    fprintf(Uoutput," @ '%.*s'",50,a->text);
  fprintf(Uoutput,"\n");
}

void Print_Inuse_List(FILE *output, int indent)
{ Uoutput = output;
  Uindent = indent + 2;
  fprintf(output,"%*sArrays:\n",indent,"");
  Array_List(Uhandler);
  fprintf(output,"%*sSlices:\n",indent,"");
  Slice_List(Shandler);
  fprintf(output,"%*sFrames:\n",indent,"");
  Frame_List(Fhandler);
}

void Print_Array(AForm *o, FILE *output, int indent, string format)
{ Array      *a     = AForm_Array(o);
  int         ndims = a->ndims;
  int         kind  = AForm_Kind(o);
  Size_Type   e     = AForm_Size(o);
  Coordinate *base  = AForm_Shape(o);
  Dimn_Type  *s     = ADIMN(base);
  Array      *low   = Copy_Array(base);
  int32      *c     = AINT32(low);

  int       d0, d1, d2, od;
  Size_Type x0, x1, n, pw;
  Indx_Type i, k, p;
  int       j;
  boolean   slice;

  if (kind != PLAIN_KIND)
    ndims -= 1;
  d0 = (kind == COMPLEX_KIND);
  d1 = (ndims >= 2) + d0;
  d2 = d1+1;
  od = (ndims-1) + d0;
  e /= kind_size[kind];

  x0 = x1 = s[d0];
  if (ndims > 1)
    x1 *= s[d1];

  slice = 0;
  if (Is_Frame(o))
    { Dimn_Type *p = ADIMN(Frame_Coordinate(o));
      int32     *v = AINT32(Frame_Anchor(o));
      for (i = 0; i < a->ndims; i++)
        c[i] = p[i]-v[i];
      fprintf(output,"\n%*sFrame ",indent,"");
    }
  else if (Is_Slice(o))
    { Dimn_Type *b = ADIMN(Slice_First(o));
      for (i = 0; i < a->ndims; i++)
        c[i] = b[i];
      fprintf(output,"\n%*sSlice ",indent,"");
      slice = 1;
    }
  else
    { for (i = 0; i < a->ndims; i++)
        c[i] = 0;
      fprintf(output,"\n%*sArray ",indent,"");
    }
  if (ndims >= 2)
    fprintf(output,"[%d,%d] x ",c[d1],c[d1]+(s[d1]-1));
  fprintf(output,"[%d,%d]\n",c[d0],c[d0]+(s[d0]-1));

  switch (kind) {
      case PLAIN_KIND:
        switch (a->type) {
            case UINT8_TYPE:
              { uint8 *v;

                if (Is_Frame(o))
                  v = (uint8 *) Frame_Values(o);
                else
                  v = AUINT8(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT16_TYPE:
              { uint16 *v;

                if (Is_Frame(o))
                  v = (uint16 *) Frame_Values(o);
                else
                  v = AUINT16(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT32_TYPE:
              { uint32 *v;

                if (Is_Frame(o))
                  v = (uint32 *) Frame_Values(o);
                else
                  v = AUINT32(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT64_TYPE:
              { uint64 *v;

                if (Is_Frame(o))
                  v = (uint64 *) Frame_Values(o);
                else
                  v = AUINT64(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT8_TYPE:
              { int8 *v;

                if (Is_Frame(o))
                  v = (int8 *) Frame_Values(o);
                else
                  v = AINT8(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT16_TYPE:
              { int16 *v;

                if (Is_Frame(o))
                  v = (int16 *) Frame_Values(o);
                else
                  v = AINT16(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT32_TYPE:
              { int32 *v;

                if (Is_Frame(o))
                  v = (int32 *) Frame_Values(o);
                else
                  v = AINT32(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT64_TYPE:
              { int64 *v;

                if (Is_Frame(o))
                  v = (int64 *) Frame_Values(o);
                else
                  v = AINT64(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *v;

                if (Is_Frame(o))
                  v = (float32 *) Frame_Values(o);
                else
                  v = AFLOAT32(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *v;

                if (Is_Frame(o))
                  v = (float64 *) Frame_Values(o);
                else
                  v = AFLOAT64(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
        }
        break;
      case RGB_KIND:
        switch (a->type) {
            case UINT8_TYPE:
              { uint8 *v;
                uint8 *w, *x;             

                if (Is_Frame(o))
                  v = (uint8 *) Frame_Values(o);
                else
                  v = AUINT8(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT16_TYPE:
              { uint16 *v;
                uint16 *w, *x;             

                if (Is_Frame(o))
                  v = (uint16 *) Frame_Values(o);
                else
                  v = AUINT16(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT32_TYPE:
              { uint32 *v;
                uint32 *w, *x;             

                if (Is_Frame(o))
                  v = (uint32 *) Frame_Values(o);
                else
                  v = AUINT32(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT64_TYPE:
              { uint64 *v;
                uint64 *w, *x;             

                if (Is_Frame(o))
                  v = (uint64 *) Frame_Values(o);
                else
                  v = AUINT64(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT8_TYPE:
              { int8 *v;
                int8 *w, *x;             

                if (Is_Frame(o))
                  v = (int8 *) Frame_Values(o);
                else
                  v = AINT8(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT16_TYPE:
              { int16 *v;
                int16 *w, *x;             

                if (Is_Frame(o))
                  v = (int16 *) Frame_Values(o);
                else
                  v = AINT16(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT32_TYPE:
              { int32 *v;
                int32 *w, *x;             

                if (Is_Frame(o))
                  v = (int32 *) Frame_Values(o);
                else
                  v = AINT32(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT64_TYPE:
              { int64 *v;
                int64 *w, *x;             

                if (Is_Frame(o))
                  v = (int64 *) Frame_Values(o);
                else
                  v = AINT64(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *v;
                float32 *w, *x;             

                if (Is_Frame(o))
                  v = (float32 *) Frame_Values(o);
                else
                  v = AFLOAT32(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *v;
                float64 *w, *x;             

                if (Is_Frame(o))
                  v = (float64 *) Frame_Values(o);
                else
                  v = AFLOAT64(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
        }
        break;
      case RGBA_KIND:
        switch (a->type) {
            case UINT8_TYPE:
              { uint8 *v;
                uint8 *w, *x;             
                uint8 *y;                 

                if (Is_Frame(o))
                  v = (uint8 *) Frame_Values(o);
                else
                  v = AUINT8(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT16_TYPE:
              { uint16 *v;
                uint16 *w, *x;             
                uint16 *y;                 

                if (Is_Frame(o))
                  v = (uint16 *) Frame_Values(o);
                else
                  v = AUINT16(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT32_TYPE:
              { uint32 *v;
                uint32 *w, *x;             
                uint32 *y;                 

                if (Is_Frame(o))
                  v = (uint32 *) Frame_Values(o);
                else
                  v = AUINT32(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT64_TYPE:
              { uint64 *v;
                uint64 *w, *x;             
                uint64 *y;                 

                if (Is_Frame(o))
                  v = (uint64 *) Frame_Values(o);
                else
                  v = AUINT64(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT8_TYPE:
              { int8 *v;
                int8 *w, *x;             
                int8 *y;                 

                if (Is_Frame(o))
                  v = (int8 *) Frame_Values(o);
                else
                  v = AINT8(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT16_TYPE:
              { int16 *v;
                int16 *w, *x;             
                int16 *y;                 

                if (Is_Frame(o))
                  v = (int16 *) Frame_Values(o);
                else
                  v = AINT16(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT32_TYPE:
              { int32 *v;
                int32 *w, *x;             
                int32 *y;                 

                if (Is_Frame(o))
                  v = (int32 *) Frame_Values(o);
                else
                  v = AINT32(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT64_TYPE:
              { int64 *v;
                int64 *w, *x;             
                int64 *y;                 

                if (Is_Frame(o))
                  v = (int64 *) Frame_Values(o);
                else
                  v = AINT64(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *v;
                float32 *w, *x;             
                float32 *y;                 

                if (Is_Frame(o))
                  v = (float32 *) Frame_Values(o);
                else
                  v = AFLOAT32(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *v;
                float64 *w, *x;             
                float64 *y;                 

                if (Is_Frame(o))
                  v = (float64 *) Frame_Values(o);
                else
                  v = AFLOAT64(a);

                p  = 0;
                pw = e;			
                if (slice)
                  { p  = Set_Slice_To_First(o);
                    pw = a->size / kind_size[kind];	
                  }

                w = v + pw;             
                x = w + pw;             
                y = x + pw;             

                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,"[");
                      fprintf(output,format,v[p]);
                      fprintf(output,",");
                      fprintf(output,format,w[p]);
                      fprintf(output,",");
                      fprintf(output,format,x[p]);
                      fprintf(output,",");
                      fprintf(output,format,y[p]);
                      fprintf(output,"]");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
        }
        break;
      case COMPLEX_KIND:
        switch (a->type) {
            case UINT8_TYPE:
              { uint8 *v;

                if (Is_Frame(o))
                  v = (uint8 *) Frame_Values(o);
                else
                  v = AUINT8(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT16_TYPE:
              { uint16 *v;

                if (Is_Frame(o))
                  v = (uint16 *) Frame_Values(o);
                else
                  v = AUINT16(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT32_TYPE:
              { uint32 *v;

                if (Is_Frame(o))
                  v = (uint32 *) Frame_Values(o);
                else
                  v = AUINT32(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case UINT64_TYPE:
              { uint64 *v;

                if (Is_Frame(o))
                  v = (uint64 *) Frame_Values(o);
                else
                  v = AUINT64(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT8_TYPE:
              { int8 *v;

                if (Is_Frame(o))
                  v = (int8 *) Frame_Values(o);
                else
                  v = AINT8(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT16_TYPE:
              { int16 *v;

                if (Is_Frame(o))
                  v = (int16 *) Frame_Values(o);
                else
                  v = AINT16(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT32_TYPE:
              { int32 *v;

                if (Is_Frame(o))
                  v = (int32 *) Frame_Values(o);
                else
                  v = AINT32(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case INT64_TYPE:
              { int64 *v;

                if (Is_Frame(o))
                  v = (int64 *) Frame_Values(o);
                else
                  v = AINT64(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *v;

                if (Is_Frame(o))
                  v = (float32 *) Frame_Values(o);
                else
                  v = AFLOAT32(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *v;

                if (Is_Frame(o))
                  v = (float64 *) Frame_Values(o);
                else
                  v = AFLOAT64(a);

                p  = 0;
                if (slice)
                  { p  = Set_Slice_To_First(o);
                  }


                for (i = 0; i < e; i++)
                  { if (i % x1 == 0)
                      { if (i > 0)
                          { if (s[d1] == 1)
                              fprintf(output," }\n");
                            else
                              fprintf(output,"\n%*s}\n",indent,"");
                          }
                        if (ndims > 2)
                          { fprintf(output,"\n%*s(",indent,"");
                            n = e;
                            k = i;
                            for (j = od; j > d2; j--)
                              { n /= s[j];
                                fprintf(output,"%lld,",c[j]+(k/n));
                                k = (k % n);
                              }
                            n /= s[j];
                            fprintf(output,"%lld)",c[j]+(k/n));
                          }
                        fprintf(output,"\n%*s{ ",indent,"");
                      }
                    else if (i % x0 == 0)
                      fprintf(output,"\n%*s  ",indent,"");
                    else
                      fprintf(output,", ");
                      fprintf(output,format,v[p]);
                      fprintf(output," + ");
                      if (slice)
                        p = Next_Slice_Index(o);
                      else
                        p += 1;
                      fprintf(output,format,v[p]);
                      fprintf(output,"i");
                    if (slice)
                      p = Next_Slice_Index(o);
                    else
                      p += 1;
                  }
                break;
              }
        }
        break;
  }

  if (s[d1] == 1 || d0 == d1)
    fprintf(output," }\n");
  else
    fprintf(output,"\n%*s}\n",indent,"");

  Free_Array(low);
  Free_Array(base);
}


/****************************************************************************************
 *                                                                                      *
 *  MODIFY TEXT DESCRIPTIONS                                                            *
 *                                                                                      *
 ****************************************************************************************/

void Set_Array_Text(Array *M(a), string text)
{ int len = (int) strlen(text);
  allocate_array_text(a,len+1,"Set_Array_Text");
  a->tlen = len;
  strcpy(a->text,text);
}

void Append_To_Array_Text(Array *M(a), string text)
{ int sen = (int) strlen(a->text);
  allocate_array_text(a,sen+a->tlen+1,"Append_To_Array_Text");
  a->tlen += sen;
  strcpy(a->text+sen,text);
}


/****************************************************************************************
 *                                                                                      *
 *  SUB-PLANE SELECTION                                                                 *
 *                                                                                      *
 ****************************************************************************************/


Array_Bundle *Get_Array_Plane(Array_Bundle *R(M(a)), Dimn_Type plane)
{ Dimn_Type nplanes = a->dims[a->ndims-1];
  Size_Type offset  = array_dsize(a)/nplanes;

  if (plane >= nplanes || a->ndims <= 1 /* || plane < 0 */)
    return (NULL);

  if (a->kind == COMPLEX_KIND && a->ndims > 0)
    a->kind   = COMPLEX_KIND;
  else
    a->kind   = PLAIN_KIND;
  a->ndims  = a->ndims-1;
  a->size   = a->size / nplanes;
  a->data   = ((char *) a->data) + plane*offset;

  return (a);
}


/****************************************************************************************
 *                                                                                      *
 *  COMPUTE RANGES AND SCALE IMAGES                                                     *
 *                                                                                      *
 ****************************************************************************************/

//  Compute min and max values in 'a' of type 'type' with 'length' elements

Range_Bundle *Array_Range(Range_Bundle *R(O(rng)), AForm *o)
{ Array    *a = AForm_Array(o);
  Size_Type n = AForm_Size(o);

  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          uint8  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (uint8 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.uval = max;
          rng->minval.uval = min;
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          uint16  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (uint16 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.uval = max;
          rng->minval.uval = min;
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          uint32  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (uint32 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.uval = max;
          rng->minval.uval = min;
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          uint64  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (uint64 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.uval = max;
          rng->minval.uval = min;
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          int8  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (int8 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.ival = max;
          rng->minval.ival = min;
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          int16  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (int16 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.ival = max;
          rng->minval.ival = min;
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          int32  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (int32 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.ival = max;
          rng->minval.ival = min;
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          int64  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (int64 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.ival = max;
          rng->minval.ival = min;
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          float32  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (float32 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.fval = max;
          rng->minval.fval = min;
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          float64  x, min, max;

          switch (AForm_Class(o))
          { case SLICE_CLASS:
              min = max = d[Set_Slice_To_First(o)];
              while (n-- > 1)
                { x = d[Next_Slice_Index(o)];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  d += Frame_Index(o);
                  min = max = d[off[0]];
                  while (n-- > 1)
                    { x = d[off[n]];
                      if (x < min)
                        min = x;
                      else if (x > max)
                        max = x;
                    }
                  break;
                }
              else
                d = (float64 *) Frame_Values(o);
            case ARRAY_CLASS:
              min = max = d[0];
              while (n-- > 1)
                { x = d[n];
                  if (x < min)
                    min = x;
                  else if (x > max)
                    max = x;
                }
              break;
            default:
              min = max = 0;
              break;
          }
          rng->maxval.fval = max;
          rng->minval.fval = min;
          break;
        }
  }

  return (rng);
}

APart *Scale_Array(APart *R(M(o)), double factor, double offset)
{ Size_Type n;
  Indx_Type e;
  Array    *a = AForm_Array(o);

  if (Is_Frame(o))
    { fprintf(stderr,"Scale_Array does not operate on frames\n");
      exit (1);
    }

  n = AForm_Size(o);
  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (uint8) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (uint8) (factor * (d[n] + offset));
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (uint16) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (uint16) (factor * (d[n] + offset));
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (uint32) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (uint32) (factor * (d[n] + offset));
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (uint64) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (uint64) (factor * (d[n] + offset));
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (int8) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (int8) (factor * (d[n] + offset));
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (int16) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (int16) (factor * (d[n] + offset));
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (int32) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (int32) (factor * (d[n] + offset));
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (int64) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (int64) (factor * (d[n] + offset));
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (float32) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (float32) (factor * (d[n] + offset));
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          if (Is_Slice(o))
            for (e = Set_Slice_To_First(o); n-- > 0; e = Next_Slice_Index(o))
              d[e] = (float64) (factor * (d[e] + offset));
          else
            while (n-- > 0)
              d[n] = (float64) (factor * (d[n] + offset));
          break;
        }
  }

  return (o);
}

APart *Scale_Array_To_Range(APart *R(M(o)), Value min, Value max)
{ Range_Bundle crn;
  double       f;
  Array       *a = AForm_Array(o);

  if (Is_Frame(o))
    { fprintf(stderr,"Scale_Array_To_Range does not operate on frames\n");
      exit (1);
    }

  Array_Range(&crn,o);
  switch (a->type) {
      case UINT8_TYPE:
        if (crn.maxval.uval == crn.minval.uval)
          break;
        if (min.uval == max.uval)
          break;
        f  = (double) (max.uval-min.uval);
        f /= crn.maxval.uval-crn.minval.uval;
        Scale_Array(o,f,min.uval/f-crn.minval.uval);
        break;
      case UINT16_TYPE:
        if (crn.maxval.uval == crn.minval.uval)
          break;
        if (min.uval == max.uval)
          break;
        f  = (double) (max.uval-min.uval);
        f /= crn.maxval.uval-crn.minval.uval;
        Scale_Array(o,f,min.uval/f-crn.minval.uval);
        break;
      case UINT32_TYPE:
        if (crn.maxval.uval == crn.minval.uval)
          break;
        if (min.uval == max.uval)
          break;
        f  = (double) (max.uval-min.uval);
        f /= crn.maxval.uval-crn.minval.uval;
        Scale_Array(o,f,min.uval/f-crn.minval.uval);
        break;
      case UINT64_TYPE:
        if (crn.maxval.uval == crn.minval.uval)
          break;
        if (min.uval == max.uval)
          break;
        f  = (double) (max.uval-min.uval);
        f /= crn.maxval.uval-crn.minval.uval;
        Scale_Array(o,f,min.uval/f-crn.minval.uval);
        break;
      case INT8_TYPE:
        if (crn.maxval.ival == crn.minval.ival)
          break;
        if (min.ival == max.ival)
          break;
        f  = (double) (max.ival-min.ival);
        f /= crn.maxval.ival-crn.minval.ival;
        Scale_Array(o,f,min.ival/f-crn.minval.ival);
        break;
      case INT16_TYPE:
        if (crn.maxval.ival == crn.minval.ival)
          break;
        if (min.ival == max.ival)
          break;
        f  = (double) (max.ival-min.ival);
        f /= crn.maxval.ival-crn.minval.ival;
        Scale_Array(o,f,min.ival/f-crn.minval.ival);
        break;
      case INT32_TYPE:
        if (crn.maxval.ival == crn.minval.ival)
          break;
        if (min.ival == max.ival)
          break;
        f  = (double) (max.ival-min.ival);
        f /= crn.maxval.ival-crn.minval.ival;
        Scale_Array(o,f,min.ival/f-crn.minval.ival);
        break;
      case INT64_TYPE:
        if (crn.maxval.ival == crn.minval.ival)
          break;
        if (min.ival == max.ival)
          break;
        f  = (double) (max.ival-min.ival);
        f /= crn.maxval.ival-crn.minval.ival;
        Scale_Array(o,f,min.ival/f-crn.minval.ival);
        break;
      case FLOAT32_TYPE:
        if (crn.maxval.fval == crn.minval.fval)
          break;
        if (min.fval == max.fval)
          break;
        f  = (double) (max.fval-min.fval);
        f /= crn.maxval.fval-crn.minval.fval;
        Scale_Array(o,f,min.fval/f-crn.minval.fval);
        break;
      case FLOAT64_TYPE:
        if (crn.maxval.fval == crn.minval.fval)
          break;
        if (min.fval == max.fval)
          break;
        f  = (double) (max.fval-min.fval);
        f /= crn.maxval.fval-crn.minval.fval;
        Scale_Array(o,f,min.fval/f-crn.minval.fval);
        break;
  }

  return (o);
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY SCALAR AND EL-BY-EL OPERATORS                                                 *
 *                                                                                      *
 ****************************************************************************************/

APart *Array_Op_Scalar(APart *R(M(o)), Operator op, Value_Type type, Value value)
{ Array    *a = AForm_Array(o);
  AForm    *m = o;
  uint64    uval = 0;
  int64     ival = 0;
  double    fval = 0.;
  Size_Type n;
  Indx_Type i;

  if (op == LSH_OP || op == RSH_OP)
    { if (a->type >= FLOAT32_TYPE)
        { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Scalar)\n");
          exit (1);
        }
    }
  if (Is_Frame(m))
    { fprintf(stderr,"Array_Op_Scalar does not operate on frames\n");
      exit (1);
    }

  if (type2kind[type] == UVAL)
    uval = value.uval;
  else if (type2kind[type] == IVAL)
    ival = value.ival;
  else
    fval = value.fval;

  n = AForm_Size(m);
  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          uint8  setval;
          switch (type2kind[type]) {
              case UVAL:
                { uint64 rp = (uint64) uval;
                  setval = (uint8) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { uint64 rp = (uint64) ival;
                  setval = (uint8) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { uint64 rp = (uint64) fval;
                  setval = (uint8) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint8) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint8) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          uint16  setval;
          switch (type2kind[type]) {
              case UVAL:
                { uint64 rp = (uint64) uval;
                  setval = (uint16) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { uint64 rp = (uint64) ival;
                  setval = (uint16) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { uint64 rp = (uint64) fval;
                  setval = (uint16) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint16) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint16) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          uint32  setval;
          switch (type2kind[type]) {
              case UVAL:
                { uint64 rp = (uint64) uval;
                  setval = (uint32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { uint64 rp = (uint64) ival;
                  setval = (uint32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { uint64 rp = (uint64) fval;
                  setval = (uint32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint32) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint32) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          uint64  setval;
          switch (type2kind[type]) {
              case UVAL:
                { uint64 rp = (uint64) uval;
                  setval = (uint64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { uint64 rp = (uint64) ival;
                  setval = (uint64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { uint64 rp = (uint64) fval;
                  setval = (uint64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (uint64) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (uint64) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          int8  setval;
          switch (type2kind[type]) {
              case UVAL:
                { int64 rp = (int64) uval;
                  setval = (int8) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { int64 rp = (int64) ival;
                  setval = (int8) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { int64 rp = (int64) fval;
                  setval = (int8) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int8) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int8) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          int16  setval;
          switch (type2kind[type]) {
              case UVAL:
                { int64 rp = (int64) uval;
                  setval = (int16) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { int64 rp = (int64) ival;
                  setval = (int16) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { int64 rp = (int64) fval;
                  setval = (int16) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int16) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int16) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          int32  setval;
          switch (type2kind[type]) {
              case UVAL:
                { int64 rp = (int64) uval;
                  setval = (int32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { int64 rp = (int64) ival;
                  setval = (int32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { int64 rp = (int64) fval;
                  setval = (int32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int32) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int32) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          int64  setval;
          switch (type2kind[type]) {
              case UVAL:
                { int64 rp = (int64) uval;
                  setval = (int64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] << ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] << ((int) uval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] >> ((int) uval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] >> ((int) uval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { int64 rp = (int64) ival;
                  setval = (int64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] << ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] << ((int) ival));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] >> ((int) ival));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] >> ((int) ival));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { int64 rp = (int64) fval;
                  setval = (int64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] << ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] << ((int) fval));
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (int64) (d[i] >> ((int) fval));
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (int64) (d[i] >> ((int) fval));
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          float32  setval;
          switch (type2kind[type]) {
              case UVAL:
                { double rp = (double) uval;
                  setval = (float32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { double rp = (double) ival;
                  setval = (float32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { double rp = (double) fval;
                  setval = (float32) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float32) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float32) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          float64  setval;
          switch (type2kind[type]) {
              case UVAL:
                { double rp = (double) uval;
                  setval = (float64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) pow((double) d[i],(double) uval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) pow((double) d[i],(double) uval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case IVAL:
                { double rp = (double) ival;
                  setval = (float64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) pow((double) d[i],(double) ival);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) pow((double) d[i],(double) ival);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
              case FVAL:
                { double rp = (double) fval;
                  setval = (float64) rp;
                  switch (op) {
                      case SET_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = setval;
                        else
                          for (i = 0; i < n; i++)
                            d[i] = setval;
                        break;
                      case ADD_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] + rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] + rp);
                        break;
                      case SUB_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] - rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] - rp);
                        break;
                      case MUL_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] * rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] * rp);
                        break;
                      case DIV_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) (d[i] / rp);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) (d[i] / rp);
                        break;
                      case POW_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            d[i] = (float64) pow((double) d[i],(double) fval);
                        else
                          for (i = 0; i < n; i++)
                            d[i] = (float64) pow((double) d[i],(double) fval);
                        break;
                      case LSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case RSH_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            ;
                        else
                          for (i = 0; i < n; i++)
                            ;
                        break;
                      case MIN_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] > setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] > setval) d[i] = setval; }
                        break;
                      case MAX_OP:
                        if (Is_Slice(m))
                          for (i = Set_Slice_To_First(m); n-- > 0; i = Next_Slice_Index(m))
                            { if (d[i] < setval) d[i] = setval; }
                        else
                          for (i = 0; i < n; i++)
                            { if (d[i] < setval) d[i] = setval; }
                        break;
                  }
                  break;
                }
          }
          break;
        }
  }

  return (o);
}

APart *Complex_Op_Scalar(APart *R(M(o)), Operator op,
                         Value_Type type, Value rpart, Value ipart)
{ Array    *a = AForm_Array(o);
  AForm    *m = o;
  Indx_Type n;
  Indx_Type i;
  double    mag, ang;
  double    mgr, agr;

  if (AForm_Kind(o) != COMPLEX_KIND)
    { fprintf(stderr,"Array form must be of COMPLEX kind (Complex_Op_Scalar)\n");
      exit (1);
    }
  if (op == LSH_OP || op == RSH_OP)
    { if (a->type >= FLOAT32_TYPE)
        { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Scalar)\n");
          exit (1);
        }
    }
  if (Is_Frame(m))
    { fprintf(stderr,"Complex_Op_Scalar does not operate on frames\n");
      exit (1);
    }

  n = AForm_Size(m);
  switch (a->type) {
    case UINT8_TYPE:
      { uint8 *d = AUINT8(a);
        uint8 *D = d+1;
        uint8  dr, di;
        uint8  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { uint64 rp = (uint64) rpart.uval;
              uint64 ip = (uint64) ipart.uval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint8) rp;
              setip = (uint8) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] + rp);
                        D[i] = (uint8) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] + rp);
                        D[i] = (uint8) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] - rp);
                        D[i] = (uint8) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] - rp);
                        D[i] = (uint8) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) (dr*rp - di*ip);
                        D[i] = (uint8) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) (dr*rp - di*ip);
                        D[i] = (uint8) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) ((dr*rp + di*ip) / em);
                        D[i] = (uint8) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) ((dr*rp + di*ip) / em);
                        D[i] = (uint8) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint8) (mgr * cos(agr));
                        D[i] = (uint8) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint8) (mgr * cos(agr));
                        D[i] = (uint8) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] << ((int) rp));
                        D[i] = (uint8) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] << ((int) rp));
                        D[i] = (uint8) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] >> ((int) rp));
                        D[i] = (uint8) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] >> ((int) rp));
                        D[i] = (uint8) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { uint64 rp = (uint64) rpart.ival;
              uint64 ip = (uint64) ipart.ival;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint8) rp;
              setip = (uint8) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] + rp);
                        D[i] = (uint8) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] + rp);
                        D[i] = (uint8) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] - rp);
                        D[i] = (uint8) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] - rp);
                        D[i] = (uint8) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) (dr*rp - di*ip);
                        D[i] = (uint8) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) (dr*rp - di*ip);
                        D[i] = (uint8) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) ((dr*rp + di*ip) / em);
                        D[i] = (uint8) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) ((dr*rp + di*ip) / em);
                        D[i] = (uint8) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint8) (mgr * cos(agr));
                        D[i] = (uint8) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint8) (mgr * cos(agr));
                        D[i] = (uint8) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] << ((int) rp));
                        D[i] = (uint8) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] << ((int) rp));
                        D[i] = (uint8) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] >> ((int) rp));
                        D[i] = (uint8) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] >> ((int) rp));
                        D[i] = (uint8) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { uint64 rp = (uint64) rpart.fval;
              uint64 ip = (uint64) ipart.fval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint8) rp;
              setip = (uint8) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] + rp);
                        D[i] = (uint8) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] + rp);
                        D[i] = (uint8) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] - rp);
                        D[i] = (uint8) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] - rp);
                        D[i] = (uint8) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) (dr*rp - di*ip);
                        D[i] = (uint8) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) (dr*rp - di*ip);
                        D[i] = (uint8) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) ((dr*rp + di*ip) / em);
                        D[i] = (uint8) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint8) ((dr*rp + di*ip) / em);
                        D[i] = (uint8) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint8) (mgr * cos(agr));
                        D[i] = (uint8) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint8) (mgr * cos(agr));
                        D[i] = (uint8) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] << ((int) rp));
                        D[i] = (uint8) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] << ((int) rp));
                        D[i] = (uint8) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint8) (d[i] >> ((int) rp));
                        D[i] = (uint8) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint8) (d[i] >> ((int) rp));
                        D[i] = (uint8) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case UINT16_TYPE:
      { uint16 *d = AUINT16(a);
        uint16 *D = d+1;
        uint16  dr, di;
        uint16  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { uint64 rp = (uint64) rpart.uval;
              uint64 ip = (uint64) ipart.uval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint16) rp;
              setip = (uint16) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] + rp);
                        D[i] = (uint16) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] + rp);
                        D[i] = (uint16) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] - rp);
                        D[i] = (uint16) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] - rp);
                        D[i] = (uint16) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) (dr*rp - di*ip);
                        D[i] = (uint16) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) (dr*rp - di*ip);
                        D[i] = (uint16) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) ((dr*rp + di*ip) / em);
                        D[i] = (uint16) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) ((dr*rp + di*ip) / em);
                        D[i] = (uint16) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint16) (mgr * cos(agr));
                        D[i] = (uint16) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint16) (mgr * cos(agr));
                        D[i] = (uint16) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] << ((int) rp));
                        D[i] = (uint16) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] << ((int) rp));
                        D[i] = (uint16) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] >> ((int) rp));
                        D[i] = (uint16) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] >> ((int) rp));
                        D[i] = (uint16) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { uint64 rp = (uint64) rpart.ival;
              uint64 ip = (uint64) ipart.ival;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint16) rp;
              setip = (uint16) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] + rp);
                        D[i] = (uint16) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] + rp);
                        D[i] = (uint16) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] - rp);
                        D[i] = (uint16) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] - rp);
                        D[i] = (uint16) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) (dr*rp - di*ip);
                        D[i] = (uint16) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) (dr*rp - di*ip);
                        D[i] = (uint16) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) ((dr*rp + di*ip) / em);
                        D[i] = (uint16) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) ((dr*rp + di*ip) / em);
                        D[i] = (uint16) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint16) (mgr * cos(agr));
                        D[i] = (uint16) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint16) (mgr * cos(agr));
                        D[i] = (uint16) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] << ((int) rp));
                        D[i] = (uint16) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] << ((int) rp));
                        D[i] = (uint16) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] >> ((int) rp));
                        D[i] = (uint16) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] >> ((int) rp));
                        D[i] = (uint16) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { uint64 rp = (uint64) rpart.fval;
              uint64 ip = (uint64) ipart.fval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint16) rp;
              setip = (uint16) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] + rp);
                        D[i] = (uint16) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] + rp);
                        D[i] = (uint16) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] - rp);
                        D[i] = (uint16) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] - rp);
                        D[i] = (uint16) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) (dr*rp - di*ip);
                        D[i] = (uint16) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) (dr*rp - di*ip);
                        D[i] = (uint16) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) ((dr*rp + di*ip) / em);
                        D[i] = (uint16) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint16) ((dr*rp + di*ip) / em);
                        D[i] = (uint16) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint16) (mgr * cos(agr));
                        D[i] = (uint16) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint16) (mgr * cos(agr));
                        D[i] = (uint16) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] << ((int) rp));
                        D[i] = (uint16) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] << ((int) rp));
                        D[i] = (uint16) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint16) (d[i] >> ((int) rp));
                        D[i] = (uint16) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint16) (d[i] >> ((int) rp));
                        D[i] = (uint16) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case UINT32_TYPE:
      { uint32 *d = AUINT32(a);
        uint32 *D = d+1;
        uint32  dr, di;
        uint32  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { uint64 rp = (uint64) rpart.uval;
              uint64 ip = (uint64) ipart.uval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint32) rp;
              setip = (uint32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] + rp);
                        D[i] = (uint32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] + rp);
                        D[i] = (uint32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] - rp);
                        D[i] = (uint32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] - rp);
                        D[i] = (uint32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) (dr*rp - di*ip);
                        D[i] = (uint32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) (dr*rp - di*ip);
                        D[i] = (uint32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) ((dr*rp + di*ip) / em);
                        D[i] = (uint32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) ((dr*rp + di*ip) / em);
                        D[i] = (uint32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint32) (mgr * cos(agr));
                        D[i] = (uint32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint32) (mgr * cos(agr));
                        D[i] = (uint32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] << ((int) rp));
                        D[i] = (uint32) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] << ((int) rp));
                        D[i] = (uint32) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] >> ((int) rp));
                        D[i] = (uint32) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] >> ((int) rp));
                        D[i] = (uint32) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { uint64 rp = (uint64) rpart.ival;
              uint64 ip = (uint64) ipart.ival;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint32) rp;
              setip = (uint32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] + rp);
                        D[i] = (uint32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] + rp);
                        D[i] = (uint32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] - rp);
                        D[i] = (uint32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] - rp);
                        D[i] = (uint32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) (dr*rp - di*ip);
                        D[i] = (uint32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) (dr*rp - di*ip);
                        D[i] = (uint32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) ((dr*rp + di*ip) / em);
                        D[i] = (uint32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) ((dr*rp + di*ip) / em);
                        D[i] = (uint32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint32) (mgr * cos(agr));
                        D[i] = (uint32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint32) (mgr * cos(agr));
                        D[i] = (uint32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] << ((int) rp));
                        D[i] = (uint32) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] << ((int) rp));
                        D[i] = (uint32) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] >> ((int) rp));
                        D[i] = (uint32) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] >> ((int) rp));
                        D[i] = (uint32) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { uint64 rp = (uint64) rpart.fval;
              uint64 ip = (uint64) ipart.fval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint32) rp;
              setip = (uint32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] + rp);
                        D[i] = (uint32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] + rp);
                        D[i] = (uint32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] - rp);
                        D[i] = (uint32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] - rp);
                        D[i] = (uint32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) (dr*rp - di*ip);
                        D[i] = (uint32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) (dr*rp - di*ip);
                        D[i] = (uint32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) ((dr*rp + di*ip) / em);
                        D[i] = (uint32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint32) ((dr*rp + di*ip) / em);
                        D[i] = (uint32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint32) (mgr * cos(agr));
                        D[i] = (uint32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint32) (mgr * cos(agr));
                        D[i] = (uint32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] << ((int) rp));
                        D[i] = (uint32) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] << ((int) rp));
                        D[i] = (uint32) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint32) (d[i] >> ((int) rp));
                        D[i] = (uint32) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint32) (d[i] >> ((int) rp));
                        D[i] = (uint32) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case UINT64_TYPE:
      { uint64 *d = AUINT64(a);
        uint64 *D = d+1;
        uint64  dr, di;
        uint64  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { uint64 rp = (uint64) rpart.uval;
              uint64 ip = (uint64) ipart.uval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint64) rp;
              setip = (uint64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] + rp);
                        D[i] = (uint64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] + rp);
                        D[i] = (uint64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] - rp);
                        D[i] = (uint64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] - rp);
                        D[i] = (uint64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) (dr*rp - di*ip);
                        D[i] = (uint64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) (dr*rp - di*ip);
                        D[i] = (uint64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) ((dr*rp + di*ip) / em);
                        D[i] = (uint64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) ((dr*rp + di*ip) / em);
                        D[i] = (uint64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint64) (mgr * cos(agr));
                        D[i] = (uint64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint64) (mgr * cos(agr));
                        D[i] = (uint64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] << ((int) rp));
                        D[i] = (uint64) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] << ((int) rp));
                        D[i] = (uint64) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] >> ((int) rp));
                        D[i] = (uint64) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] >> ((int) rp));
                        D[i] = (uint64) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { uint64 rp = (uint64) rpart.ival;
              uint64 ip = (uint64) ipart.ival;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint64) rp;
              setip = (uint64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] + rp);
                        D[i] = (uint64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] + rp);
                        D[i] = (uint64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] - rp);
                        D[i] = (uint64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] - rp);
                        D[i] = (uint64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) (dr*rp - di*ip);
                        D[i] = (uint64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) (dr*rp - di*ip);
                        D[i] = (uint64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) ((dr*rp + di*ip) / em);
                        D[i] = (uint64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) ((dr*rp + di*ip) / em);
                        D[i] = (uint64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint64) (mgr * cos(agr));
                        D[i] = (uint64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint64) (mgr * cos(agr));
                        D[i] = (uint64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] << ((int) rp));
                        D[i] = (uint64) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] << ((int) rp));
                        D[i] = (uint64) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] >> ((int) rp));
                        D[i] = (uint64) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] >> ((int) rp));
                        D[i] = (uint64) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { uint64 rp = (uint64) rpart.fval;
              uint64 ip = (uint64) ipart.fval;
              uint64 em = rp*rp + ip*ip;
              setrp = (uint64) rp;
              setip = (uint64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] + rp);
                        D[i] = (uint64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] + rp);
                        D[i] = (uint64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] - rp);
                        D[i] = (uint64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] - rp);
                        D[i] = (uint64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) (dr*rp - di*ip);
                        D[i] = (uint64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) (dr*rp - di*ip);
                        D[i] = (uint64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) ((dr*rp + di*ip) / em);
                        D[i] = (uint64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (uint64) ((dr*rp + di*ip) / em);
                        D[i] = (uint64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint64) (mgr * cos(agr));
                        D[i] = (uint64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (uint64) (mgr * cos(agr));
                        D[i] = (uint64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] << ((int) rp));
                        D[i] = (uint64) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] << ((int) rp));
                        D[i] = (uint64) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (uint64) (d[i] >> ((int) rp));
                        D[i] = (uint64) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (uint64) (d[i] >> ((int) rp));
                        D[i] = (uint64) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT8_TYPE:
      { int8 *d = AINT8(a);
        int8 *D = d+1;
        int8  dr, di;
        int8  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { int64 rp = (int64) rpart.uval;
              int64 ip = (int64) ipart.uval;
              int64 em = rp*rp + ip*ip;
              setrp = (int8) rp;
              setip = (int8) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] + rp);
                        D[i] = (int8) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] + rp);
                        D[i] = (int8) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] - rp);
                        D[i] = (int8) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] - rp);
                        D[i] = (int8) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) (dr*rp - di*ip);
                        D[i] = (int8) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) (dr*rp - di*ip);
                        D[i] = (int8) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) ((dr*rp + di*ip) / em);
                        D[i] = (int8) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) ((dr*rp + di*ip) / em);
                        D[i] = (int8) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int8) (mgr * cos(agr));
                        D[i] = (int8) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int8) (mgr * cos(agr));
                        D[i] = (int8) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] << ((int) rp));
                        D[i] = (int8) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] << ((int) rp));
                        D[i] = (int8) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] >> ((int) rp));
                        D[i] = (int8) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] >> ((int) rp));
                        D[i] = (int8) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = (int64) rpart.ival;
              int64 ip = (int64) ipart.ival;
              int64 em = rp*rp + ip*ip;
              setrp = (int8) rp;
              setip = (int8) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] + rp);
                        D[i] = (int8) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] + rp);
                        D[i] = (int8) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] - rp);
                        D[i] = (int8) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] - rp);
                        D[i] = (int8) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) (dr*rp - di*ip);
                        D[i] = (int8) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) (dr*rp - di*ip);
                        D[i] = (int8) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) ((dr*rp + di*ip) / em);
                        D[i] = (int8) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) ((dr*rp + di*ip) / em);
                        D[i] = (int8) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int8) (mgr * cos(agr));
                        D[i] = (int8) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int8) (mgr * cos(agr));
                        D[i] = (int8) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] << ((int) rp));
                        D[i] = (int8) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] << ((int) rp));
                        D[i] = (int8) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] >> ((int) rp));
                        D[i] = (int8) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] >> ((int) rp));
                        D[i] = (int8) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { int64 rp = (int64) rpart.fval;
              int64 ip = (int64) ipart.fval;
              int64 em = rp*rp + ip*ip;
              setrp = (int8) rp;
              setip = (int8) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] + rp);
                        D[i] = (int8) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] + rp);
                        D[i] = (int8) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] - rp);
                        D[i] = (int8) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] - rp);
                        D[i] = (int8) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) (dr*rp - di*ip);
                        D[i] = (int8) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) (dr*rp - di*ip);
                        D[i] = (int8) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) ((dr*rp + di*ip) / em);
                        D[i] = (int8) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int8) ((dr*rp + di*ip) / em);
                        D[i] = (int8) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int8) (mgr * cos(agr));
                        D[i] = (int8) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int8) (mgr * cos(agr));
                        D[i] = (int8) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] << ((int) rp));
                        D[i] = (int8) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] << ((int) rp));
                        D[i] = (int8) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int8) (d[i] >> ((int) rp));
                        D[i] = (int8) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int8) (d[i] >> ((int) rp));
                        D[i] = (int8) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT16_TYPE:
      { int16 *d = AINT16(a);
        int16 *D = d+1;
        int16  dr, di;
        int16  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { int64 rp = (int64) rpart.uval;
              int64 ip = (int64) ipart.uval;
              int64 em = rp*rp + ip*ip;
              setrp = (int16) rp;
              setip = (int16) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] + rp);
                        D[i] = (int16) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] + rp);
                        D[i] = (int16) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] - rp);
                        D[i] = (int16) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] - rp);
                        D[i] = (int16) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) (dr*rp - di*ip);
                        D[i] = (int16) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) (dr*rp - di*ip);
                        D[i] = (int16) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) ((dr*rp + di*ip) / em);
                        D[i] = (int16) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) ((dr*rp + di*ip) / em);
                        D[i] = (int16) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int16) (mgr * cos(agr));
                        D[i] = (int16) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int16) (mgr * cos(agr));
                        D[i] = (int16) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] << ((int) rp));
                        D[i] = (int16) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] << ((int) rp));
                        D[i] = (int16) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] >> ((int) rp));
                        D[i] = (int16) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] >> ((int) rp));
                        D[i] = (int16) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = (int64) rpart.ival;
              int64 ip = (int64) ipart.ival;
              int64 em = rp*rp + ip*ip;
              setrp = (int16) rp;
              setip = (int16) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] + rp);
                        D[i] = (int16) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] + rp);
                        D[i] = (int16) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] - rp);
                        D[i] = (int16) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] - rp);
                        D[i] = (int16) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) (dr*rp - di*ip);
                        D[i] = (int16) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) (dr*rp - di*ip);
                        D[i] = (int16) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) ((dr*rp + di*ip) / em);
                        D[i] = (int16) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) ((dr*rp + di*ip) / em);
                        D[i] = (int16) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int16) (mgr * cos(agr));
                        D[i] = (int16) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int16) (mgr * cos(agr));
                        D[i] = (int16) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] << ((int) rp));
                        D[i] = (int16) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] << ((int) rp));
                        D[i] = (int16) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] >> ((int) rp));
                        D[i] = (int16) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] >> ((int) rp));
                        D[i] = (int16) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { int64 rp = (int64) rpart.fval;
              int64 ip = (int64) ipart.fval;
              int64 em = rp*rp + ip*ip;
              setrp = (int16) rp;
              setip = (int16) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] + rp);
                        D[i] = (int16) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] + rp);
                        D[i] = (int16) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] - rp);
                        D[i] = (int16) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] - rp);
                        D[i] = (int16) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) (dr*rp - di*ip);
                        D[i] = (int16) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) (dr*rp - di*ip);
                        D[i] = (int16) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) ((dr*rp + di*ip) / em);
                        D[i] = (int16) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int16) ((dr*rp + di*ip) / em);
                        D[i] = (int16) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int16) (mgr * cos(agr));
                        D[i] = (int16) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int16) (mgr * cos(agr));
                        D[i] = (int16) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] << ((int) rp));
                        D[i] = (int16) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] << ((int) rp));
                        D[i] = (int16) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int16) (d[i] >> ((int) rp));
                        D[i] = (int16) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int16) (d[i] >> ((int) rp));
                        D[i] = (int16) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT32_TYPE:
      { int32 *d = AINT32(a);
        int32 *D = d+1;
        int32  dr, di;
        int32  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { int64 rp = (int64) rpart.uval;
              int64 ip = (int64) ipart.uval;
              int64 em = rp*rp + ip*ip;
              setrp = (int32) rp;
              setip = (int32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] + rp);
                        D[i] = (int32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] + rp);
                        D[i] = (int32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] - rp);
                        D[i] = (int32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] - rp);
                        D[i] = (int32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) (dr*rp - di*ip);
                        D[i] = (int32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) (dr*rp - di*ip);
                        D[i] = (int32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) ((dr*rp + di*ip) / em);
                        D[i] = (int32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) ((dr*rp + di*ip) / em);
                        D[i] = (int32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int32) (mgr * cos(agr));
                        D[i] = (int32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int32) (mgr * cos(agr));
                        D[i] = (int32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] << ((int) rp));
                        D[i] = (int32) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] << ((int) rp));
                        D[i] = (int32) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] >> ((int) rp));
                        D[i] = (int32) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] >> ((int) rp));
                        D[i] = (int32) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = (int64) rpart.ival;
              int64 ip = (int64) ipart.ival;
              int64 em = rp*rp + ip*ip;
              setrp = (int32) rp;
              setip = (int32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] + rp);
                        D[i] = (int32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] + rp);
                        D[i] = (int32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] - rp);
                        D[i] = (int32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] - rp);
                        D[i] = (int32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) (dr*rp - di*ip);
                        D[i] = (int32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) (dr*rp - di*ip);
                        D[i] = (int32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) ((dr*rp + di*ip) / em);
                        D[i] = (int32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) ((dr*rp + di*ip) / em);
                        D[i] = (int32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int32) (mgr * cos(agr));
                        D[i] = (int32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int32) (mgr * cos(agr));
                        D[i] = (int32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] << ((int) rp));
                        D[i] = (int32) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] << ((int) rp));
                        D[i] = (int32) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] >> ((int) rp));
                        D[i] = (int32) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] >> ((int) rp));
                        D[i] = (int32) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { int64 rp = (int64) rpart.fval;
              int64 ip = (int64) ipart.fval;
              int64 em = rp*rp + ip*ip;
              setrp = (int32) rp;
              setip = (int32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] + rp);
                        D[i] = (int32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] + rp);
                        D[i] = (int32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] - rp);
                        D[i] = (int32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] - rp);
                        D[i] = (int32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) (dr*rp - di*ip);
                        D[i] = (int32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) (dr*rp - di*ip);
                        D[i] = (int32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) ((dr*rp + di*ip) / em);
                        D[i] = (int32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int32) ((dr*rp + di*ip) / em);
                        D[i] = (int32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int32) (mgr * cos(agr));
                        D[i] = (int32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int32) (mgr * cos(agr));
                        D[i] = (int32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] << ((int) rp));
                        D[i] = (int32) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] << ((int) rp));
                        D[i] = (int32) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int32) (d[i] >> ((int) rp));
                        D[i] = (int32) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int32) (d[i] >> ((int) rp));
                        D[i] = (int32) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case INT64_TYPE:
      { int64 *d = AINT64(a);
        int64 *D = d+1;
        int64  dr, di;
        int64  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { int64 rp = (int64) rpart.uval;
              int64 ip = (int64) ipart.uval;
              int64 em = rp*rp + ip*ip;
              setrp = (int64) rp;
              setip = (int64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] + rp);
                        D[i] = (int64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] + rp);
                        D[i] = (int64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] - rp);
                        D[i] = (int64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] - rp);
                        D[i] = (int64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) (dr*rp - di*ip);
                        D[i] = (int64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) (dr*rp - di*ip);
                        D[i] = (int64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) ((dr*rp + di*ip) / em);
                        D[i] = (int64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) ((dr*rp + di*ip) / em);
                        D[i] = (int64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int64) (mgr * cos(agr));
                        D[i] = (int64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int64) (mgr * cos(agr));
                        D[i] = (int64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] << ((int) rp));
                        D[i] = (int64) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] << ((int) rp));
                        D[i] = (int64) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] >> ((int) rp));
                        D[i] = (int64) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] >> ((int) rp));
                        D[i] = (int64) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { int64 rp = (int64) rpart.ival;
              int64 ip = (int64) ipart.ival;
              int64 em = rp*rp + ip*ip;
              setrp = (int64) rp;
              setip = (int64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] + rp);
                        D[i] = (int64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] + rp);
                        D[i] = (int64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] - rp);
                        D[i] = (int64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] - rp);
                        D[i] = (int64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) (dr*rp - di*ip);
                        D[i] = (int64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) (dr*rp - di*ip);
                        D[i] = (int64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) ((dr*rp + di*ip) / em);
                        D[i] = (int64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) ((dr*rp + di*ip) / em);
                        D[i] = (int64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int64) (mgr * cos(agr));
                        D[i] = (int64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int64) (mgr * cos(agr));
                        D[i] = (int64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] << ((int) rp));
                        D[i] = (int64) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] << ((int) rp));
                        D[i] = (int64) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] >> ((int) rp));
                        D[i] = (int64) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] >> ((int) rp));
                        D[i] = (int64) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { int64 rp = (int64) rpart.fval;
              int64 ip = (int64) ipart.fval;
              int64 em = rp*rp + ip*ip;
              setrp = (int64) rp;
              setip = (int64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] + rp);
                        D[i] = (int64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] + rp);
                        D[i] = (int64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] - rp);
                        D[i] = (int64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] - rp);
                        D[i] = (int64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) (dr*rp - di*ip);
                        D[i] = (int64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) (dr*rp - di*ip);
                        D[i] = (int64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) ((dr*rp + di*ip) / em);
                        D[i] = (int64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (int64) ((dr*rp + di*ip) / em);
                        D[i] = (int64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int64) (mgr * cos(agr));
                        D[i] = (int64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (int64) (mgr * cos(agr));
                        D[i] = (int64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] << ((int) rp));
                        D[i] = (int64) (D[i] << ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] << ((int) rp));
                        D[i] = (int64) (D[i] << ((int) ip));
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (int64) (d[i] >> ((int) rp));
                        D[i] = (int64) (D[i] >> ((int) ip));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (int64) (d[i] >> ((int) rp));
                        D[i] = (int64) (D[i] >> ((int) ip));
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case FLOAT32_TYPE:
      { float32 *d = AFLOAT32(a);
        float32 *D = d+1;
        float32  dr, di;
        float32  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { double rp = (double) rpart.uval;
              double ip = (double) ipart.uval;
              double em = rp*rp + ip*ip;
              setrp = (float32) rp;
              setip = (float32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float32) (d[i] + rp);
                        D[i] = (float32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float32) (d[i] + rp);
                        D[i] = (float32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float32) (d[i] - rp);
                        D[i] = (float32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float32) (d[i] - rp);
                        D[i] = (float32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) (dr*rp - di*ip);
                        D[i] = (float32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) (dr*rp - di*ip);
                        D[i] = (float32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) ((dr*rp + di*ip) / em);
                        D[i] = (float32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) ((dr*rp + di*ip) / em);
                        D[i] = (float32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float32) (mgr * cos(agr));
                        D[i] = (float32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float32) (mgr * cos(agr));
                        D[i] = (float32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { double rp = (double) rpart.ival;
              double ip = (double) ipart.ival;
              double em = rp*rp + ip*ip;
              setrp = (float32) rp;
              setip = (float32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float32) (d[i] + rp);
                        D[i] = (float32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float32) (d[i] + rp);
                        D[i] = (float32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float32) (d[i] - rp);
                        D[i] = (float32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float32) (d[i] - rp);
                        D[i] = (float32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) (dr*rp - di*ip);
                        D[i] = (float32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) (dr*rp - di*ip);
                        D[i] = (float32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) ((dr*rp + di*ip) / em);
                        D[i] = (float32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) ((dr*rp + di*ip) / em);
                        D[i] = (float32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float32) (mgr * cos(agr));
                        D[i] = (float32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float32) (mgr * cos(agr));
                        D[i] = (float32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { double rp = (double) rpart.fval;
              double ip = (double) ipart.fval;
              double em = rp*rp + ip*ip;
              setrp = (float32) rp;
              setip = (float32) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float32) (d[i] + rp);
                        D[i] = (float32) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float32) (d[i] + rp);
                        D[i] = (float32) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float32) (d[i] - rp);
                        D[i] = (float32) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float32) (d[i] - rp);
                        D[i] = (float32) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) (dr*rp - di*ip);
                        D[i] = (float32) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) (dr*rp - di*ip);
                        D[i] = (float32) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) ((dr*rp + di*ip) / em);
                        D[i] = (float32) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float32) ((dr*rp + di*ip) / em);
                        D[i] = (float32) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float32) (mgr * cos(agr));
                        D[i] = (float32) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float32) (mgr * cos(agr));
                        D[i] = (float32) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    case FLOAT64_TYPE:
      { float64 *d = AFLOAT64(a);
        float64 *D = d+1;
        float64  dr, di;
        float64  setrp, setip;
        switch (type2kind[type]) {
          case UVAL:
            { double rp = (double) rpart.uval;
              double ip = (double) ipart.uval;
              double em = rp*rp + ip*ip;
              setrp = (float64) rp;
              setip = (float64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float64) (d[i] + rp);
                        D[i] = (float64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float64) (d[i] + rp);
                        D[i] = (float64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float64) (d[i] - rp);
                        D[i] = (float64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float64) (d[i] - rp);
                        D[i] = (float64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) (dr*rp - di*ip);
                        D[i] = (float64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) (dr*rp - di*ip);
                        D[i] = (float64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) ((dr*rp + di*ip) / em);
                        D[i] = (float64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) ((dr*rp + di*ip) / em);
                        D[i] = (float64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float64) (mgr * cos(agr));
                        D[i] = (float64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float64) (mgr * cos(agr));
                        D[i] = (float64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case IVAL:
            { double rp = (double) rpart.ival;
              double ip = (double) ipart.ival;
              double em = rp*rp + ip*ip;
              setrp = (float64) rp;
              setip = (float64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float64) (d[i] + rp);
                        D[i] = (float64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float64) (d[i] + rp);
                        D[i] = (float64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float64) (d[i] - rp);
                        D[i] = (float64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float64) (d[i] - rp);
                        D[i] = (float64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) (dr*rp - di*ip);
                        D[i] = (float64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) (dr*rp - di*ip);
                        D[i] = (float64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) ((dr*rp + di*ip) / em);
                        D[i] = (float64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) ((dr*rp + di*ip) / em);
                        D[i] = (float64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float64) (mgr * cos(agr));
                        D[i] = (float64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float64) (mgr * cos(agr));
                        D[i] = (float64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          case FVAL:
            { double rp = (double) rpart.fval;
              double ip = (double) ipart.fval;
              double em = rp*rp + ip*ip;
              setrp = (float64) rp;
              setip = (float64) ip;
              switch (op) {
                case SET_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = setrp;
                        D[i] = setip;
                      }
                  break;
                case ADD_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float64) (d[i] + rp);
                        D[i] = (float64) (D[i] + ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float64) (d[i] + rp);
                        D[i] = (float64) (D[i] + ip);
                      }
                  break;
                case SUB_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { d[i] = (float64) (d[i] - rp);
                        D[i] = (float64) (D[i] - ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { d[i] = (float64) (d[i] - rp);
                        D[i] = (float64) (D[i] - ip);
                      }
                  break;
                case MUL_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) (dr*rp - di*ip);
                        D[i] = (float64) (di*rp + dr*ip);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) (dr*rp - di*ip);
                        D[i] = (float64) (di*rp + dr*ip);
                      }
                  break;
                case DIV_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) ((dr*rp + di*ip) / em);
                        D[i] = (float64) ((di*rp - dr*ip) / em);
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        d[i] = (float64) ((dr*rp + di*ip) / em);
                        D[i] = (float64) ((di*rp - dr*ip) / em);
                      }
                  break;
                case POW_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float64) (mgr * cos(agr));
                        D[i] = (float64) (mgr * sin(agr));
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { dr = d[i];
                        di = D[i];
                        mag  = (double) (di*di + dr*dr);
                        ang  = atan2((double) di,(double) dr);
                        mgr = pow(mag,.5*rp) * exp((-ang)*ip);
                        agr = .5*ip*log(mag) + rp*ang;
                        d[i] = (float64) (mgr * cos(agr));
                        D[i] = (float64) (mgr * sin(agr));
                      }
                  break;
                case LSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case RSH_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { ;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { ;
                      }
                  break;
                case MIN_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] > setrp) d[i] = setrp;
                        if (D[i] > setip) D[i] = setip;
                      }
                  break;
                case MAX_OP:
                  if (Is_Slice(m))
                    for (i = Set_Slice_To_First(m); n-- > 0; n--, Next_Slice_Index(m),
                                                              i = Next_Slice_Index(m))
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  else
                    for (i = 0; i < n; i += 2)
                      { if (d[i] < setrp) d[i] = setrp;
                        if (D[i] < setip) D[i] = setip;
                      }
                  break;
                }
              break;
            }
          }
        break;
      }
    }

  return (o);
}

#define AOA_BUFLEN  0x40000

static pthread_mutex_t Buffer_Mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t  Buffer_Cond  = PTHREAD_COND_INITIALIZER;

static int    AA_NoInit = 1;
static int    AA_BufAlloc[NUM_THREADS];
static double AA_Buffer[AOA_BUFLEN*NUM_THREADS];

static double *Get_AOA_Buffer()
{ int i;

  pthread_mutex_lock(&Buffer_Mutex);
  if (AA_NoInit)
    { AA_NoInit = 0;
      for (i = 0; i < NUM_THREADS; i++)
        AA_BufAlloc[i] = 0;
    }
  while (1)
    { for (i = 0; i < NUM_THREADS; i++)
        if (AA_BufAlloc[i] == 0)
          { AA_BufAlloc[i] = 1;
            break;
          }
      if (i < NUM_THREADS)
        break;
      pthread_cond_wait(&Buffer_Cond,&Buffer_Mutex);
    }
  pthread_mutex_unlock(&Buffer_Mutex);

  return (AA_Buffer + AOA_BUFLEN*i);
}

static void Release_AOA_Buffer(void *buf)
{ pthread_mutex_lock(&Buffer_Mutex);
  AA_BufAlloc[(((double *) buf)-AA_Buffer)/AOA_BUFLEN] = 0;
  pthread_cond_signal(&Buffer_Cond);
  pthread_mutex_unlock(&Buffer_Mutex);
}


  static Indx_Type load_buffer_uval(uint64 *buffer, AForm *q,
                                   Size_Type crea, Indx_Type j, Size_Type brea)
  { Array    *b = AForm_Array(q);
    Indx_Type i;

    switch (b->type) {
      case UINT8_TYPE:
        { uint8 *e = AUINT8(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { uint8 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case UINT16_TYPE:
        { uint16 *e = AUINT16(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { uint16 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case UINT32_TYPE:
        { uint32 *e = AUINT32(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { uint32 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case UINT64_TYPE:
        { uint64 *e = AUINT64(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { uint64 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
    default:
      break;
    }
    return (j);
  }

  static Indx_Type load_buffer_ival(int64 *buffer, AForm *q,
                                   Size_Type crea, Indx_Type j, Size_Type brea)
  { Array    *b = AForm_Array(q);
    Indx_Type i;

    switch (b->type) {
      case INT8_TYPE:
        { int8 *e = AINT8(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { int8 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case INT16_TYPE:
        { int16 *e = AINT16(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { int16 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case INT32_TYPE:
        { int32 *e = AINT32(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { int32 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case INT64_TYPE:
        { int64 *e = AINT64(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { int64 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
    default:
      break;
    }
    return (j);
  }

  static Indx_Type load_buffer_fval(float64 *buffer, AForm *q,
                                   Size_Type crea, Indx_Type j, Size_Type brea)
  { Array    *b = AForm_Array(q);
    Indx_Type i;

    switch (b->type) {
      case FLOAT32_TYPE:
        { float32 *e = AFLOAT32(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { float32 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *e = AFLOAT64(b);
          switch (AForm_Class(q))
          { case SLICE_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j];
                  j = Next_Slice_Index(q);
                }
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(q))
                { Offs_Type *off = Frame_Offsets(q);
                  e += Frame_Index(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = e[off[j++]];
                      if (j == brea) j = 0;
                    }
                }
              else
                { float64 *v = Frame_Values(q);
                  for (i = 0; i < crea; i++)
                    { buffer[i] = v[j++];
                      if (j == brea) j = 0;
                    }
                }
              break;
            case ARRAY_CLASS:
              for (i = 0; i < crea; i++)
                { buffer[i] = e[j++];
                  if (j == brea) j = 0;
                }
              break;
          }
          break;
        }
    default:
      break;
    }
    return (j);
  }

APart *Array_Op_Array(APart *R(M(o)), Operator op, AForm *q)
{ Array *a = AForm_Array(o);
  Array *b = AForm_Array(q);
  AForm *m = o;

  boolean     alice;
  Size_Type   brea, crea;
  Indx_Type   i, j, k;
  Size_Type   volume;
  int         btype;

  if ((op == LSH_OP || op == RSH_OP) && a->type >= FLOAT32_TYPE)
    { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Array)\n");
      exit (1);
    }
  if (Is_Frame(m))
    { fprintf(stderr,"Array_Op_Array does not accept a frame as it first argument\n");
      exit (1);
    }

  alice = Is_Slice(m);

  if (op == SET_OP && a->type == b->type && !alice && Is_Array(q))
    { Size_Type as = array_size(a);
      Size_Type bs = array_size(b);
      if (bs >= as)
        memcpy(a->data,b->data,(size_t) as);
      else
        { for (i = 0; i < as; i += bs)
            if (i+bs > as)
              memcpy(((char *) a->data) + i,b->data,(size_t) (as-i));
            else
              memcpy(((char *) a->data) + i,b->data,(size_t) bs);
        }
      return (o);
    }

  if (b->type <= UINT64_TYPE)
    btype = UVAL;
  else if (b->type <= INT64_TYPE)
    btype = IVAL;
  else
    btype = FVAL;

  if (Is_Slice(q))
    j = Set_Slice_To_First(q);
  else
    j = 0;

  if (alice)
    k = Set_Slice_To_First(m);
  else
    k = 0;

  volume = AForm_Size(m);
  brea   = AForm_Size(q);

  switch (btype) {
    case UVAL:
      { uint64 *buffer = (uint64 *) Get_AOA_Buffer();
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;

            j = load_buffer_uval(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) d[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (float32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (float32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (float64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (float64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
            }
            volume -= crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    case IVAL:
      { int64 *buffer = (int64 *) Get_AOA_Buffer();
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;

            j = load_buffer_ival(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) d[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (float32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (float32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (float64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (float64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
            }
            volume -= crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    case FVAL:
      { float64 *buffer = (float64 *) Get_AOA_Buffer();
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;

            j = load_buffer_fval(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint8) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint8) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint16) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint16) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint32) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint32) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (uint64) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (uint64) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int8) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int8) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int16) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int16) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int32) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int32) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) (d[k] << (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) (d[k] << (int) buffer[i]);
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (int64) (d[k] >> (int) buffer[i]);
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (int64) (d[k] >> (int) buffer[i]);
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (float32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (float32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          d[k] = (float64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k++)
                          d[k] = (float64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) pow((double) dr,(double) er);
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) d[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) pow((double) dr,(double) er);
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          ;
                      else
                        for (i = 0; i < crea; i++, k++)
                          ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k++)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                          }
                      break;
                  }
                  break;
                }
            }
            volume -= crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
  }

  return (o);
}

APart *Complex_Op_Array(APart *R(M(o)), Operator op, AForm *q)
{ Array *a = AForm_Array(o);
  Array *b = AForm_Array(q);
  AForm *m = o;

  boolean     alice;
  Size_Type   brea, crea;
  Indx_Type   i, j, k;
  Size_Type   volume;
  int         btype;
  double      mag, ang;
  double      mgr, agr;

  if (AForm_Kind(o) != COMPLEX_KIND)
    { fprintf(stderr,"First array form must be complex (Complex_Op_Array)\n");
      exit (1);
    }
  if ((op == LSH_OP || op == RSH_OP) && a->type >= FLOAT32_TYPE)
    { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Array)\n");
      exit (1);
    }
  if (Is_Frame(m))
    { fprintf(stderr,"Complex_Op_Array does not accept a frame as it first argument\n");
      exit (1);
    }

  if (b->type <= UINT64_TYPE)
    btype = UVAL;
  else if (b->type <= INT64_TYPE)
    btype = IVAL;
  else
    btype = FVAL;

  if (Is_Slice(q))
    j = Set_Slice_To_First(q);
  else
    j = 0;

  alice = Is_Slice(m);
  if (alice)
    k = Set_Slice_To_First(m);
  else
    k = 0;

  volume = AForm_Size(m);
  brea   = AForm_Size(q);

  switch (btype) {
    case UVAL:
      { uint64 *buffer = (uint64 *) Get_AOA_Buffer();
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume/2;
            else
              crea = AOA_BUFLEN/2;

            j = load_buffer_uval(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr * er);
                            D[k] = (uint8) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr * er);
                            D[k] = (uint8) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr / er);
                            D[k] = (uint8) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint8) (dr / er);
                            D[k] = (uint8) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] << er);
                            D[k] = (uint8) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] << er);
                            D[k] = (uint8) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] >> er);
                            D[k] = (uint8) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] >> er);
                            D[k] = (uint8) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr * er);
                            D[k] = (uint16) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr * er);
                            D[k] = (uint16) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr / er);
                            D[k] = (uint16) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint16) (dr / er);
                            D[k] = (uint16) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] << er);
                            D[k] = (uint16) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] << er);
                            D[k] = (uint16) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] >> er);
                            D[k] = (uint16) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] >> er);
                            D[k] = (uint16) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr * er);
                            D[k] = (uint32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr * er);
                            D[k] = (uint32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr / er);
                            D[k] = (uint32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            d[k] = (uint32) (dr / er);
                            D[k] = (uint32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] << er);
                            D[k] = (uint32) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] << er);
                            D[k] = (uint32) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] >> er);
                            D[k] = (uint32) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] >> er);
                            D[k] = (uint32) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                            D[k] = (uint64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                            D[k] = (uint64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                            D[k] = (uint64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                            D[k] = (uint64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] << er);
                            D[k] = (uint64) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] << er);
                            D[k] = (uint64) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] >> er);
                            D[k] = (uint64) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] >> er);
                            D[k] = (uint64) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                            D[k] = (int8) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                            D[k] = (int8) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                            D[k] = (int8) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                            D[k] = (int8) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] << er);
                            D[k] = (int8) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] << er);
                            D[k] = (int8) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] >> er);
                            D[k] = (int8) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] >> er);
                            D[k] = (int8) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                            D[k] = (int16) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                            D[k] = (int16) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                            D[k] = (int16) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                            D[k] = (int16) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] << er);
                            D[k] = (int16) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] << er);
                            D[k] = (int16) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] >> er);
                            D[k] = (int16) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] >> er);
                            D[k] = (int16) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                            D[k] = (int32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                            D[k] = (int32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                            D[k] = (int32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                            D[k] = (int32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] << er);
                            D[k] = (int32) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] << er);
                            D[k] = (int32) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] >> er);
                            D[k] = (int32) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] >> er);
                            D[k] = (int32) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                            D[k] = (int64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                            D[k] = (int64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                            D[k] = (int64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                            D[k] = (int64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] << er);
                            D[k] = (int64) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] << er);
                            D[k] = (int64) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] >> er);
                            D[k] = (int64) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] >> er);
                            D[k] = (int64) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (float32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (float32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                            D[k] = (float32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                            D[k] = (float32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                            D[k] = (float32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                            D[k] = (float32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (float64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (float64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                            D[k] = (float64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                            D[k] = (float64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                            D[k] = (float64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                            D[k] = (float64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= 2*crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    case IVAL:
      { int64 *buffer = (int64 *) Get_AOA_Buffer();
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume/2;
            else
              crea = AOA_BUFLEN/2;

            j = load_buffer_ival(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr * er);
                            D[k] = (uint8) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr * er);
                            D[k] = (uint8) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr / er);
                            D[k] = (uint8) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint8) (dr / er);
                            D[k] = (uint8) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] << er);
                            D[k] = (uint8) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] << er);
                            D[k] = (uint8) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] >> er);
                            D[k] = (uint8) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] >> er);
                            D[k] = (uint8) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr * er);
                            D[k] = (uint16) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr * er);
                            D[k] = (uint16) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr / er);
                            D[k] = (uint16) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint16) (dr / er);
                            D[k] = (uint16) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] << er);
                            D[k] = (uint16) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] << er);
                            D[k] = (uint16) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] >> er);
                            D[k] = (uint16) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] >> er);
                            D[k] = (uint16) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr * er);
                            D[k] = (uint32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr * er);
                            D[k] = (uint32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr / er);
                            D[k] = (uint32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint32) (dr / er);
                            D[k] = (uint32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] << er);
                            D[k] = (uint32) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] << er);
                            D[k] = (uint32) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] >> er);
                            D[k] = (uint32) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] >> er);
                            D[k] = (uint32) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                            D[k] = (uint64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr * er);
                            D[k] = (uint64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                            D[k] = (uint64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (uint64) (dr / er);
                            D[k] = (uint64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] << er);
                            D[k] = (uint64) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] << er);
                            D[k] = (uint64) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] >> er);
                            D[k] = (uint64) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] >> er);
                            D[k] = (uint64) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                            D[k] = (int8) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr * er);
                            D[k] = (int8) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                            D[k] = (int8) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int8) (dr / er);
                            D[k] = (int8) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] << er);
                            D[k] = (int8) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] << er);
                            D[k] = (int8) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] >> er);
                            D[k] = (int8) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] >> er);
                            D[k] = (int8) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                            D[k] = (int16) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr * er);
                            D[k] = (int16) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                            D[k] = (int16) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int16) (dr / er);
                            D[k] = (int16) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] << er);
                            D[k] = (int16) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] << er);
                            D[k] = (int16) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] >> er);
                            D[k] = (int16) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] >> er);
                            D[k] = (int16) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                            D[k] = (int32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr * er);
                            D[k] = (int32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                            D[k] = (int32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int32) (dr / er);
                            D[k] = (int32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] << er);
                            D[k] = (int32) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] << er);
                            D[k] = (int32) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] >> er);
                            D[k] = (int32) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] >> er);
                            D[k] = (int32) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                            D[k] = (int64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr * er);
                            D[k] = (int64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                            D[k] = (int64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            d[k] = (int64) (dr / er);
                            D[k] = (int64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] << er);
                            D[k] = (int64) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] << er);
                            D[k] = (int64) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] >> er);
                            D[k] = (int64) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] >> er);
                            D[k] = (int64) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (float32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (float32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                            D[k] = (float32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                            D[k] = (float32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                            D[k] = (float32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                            D[k] = (float32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (float64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (float64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                            D[k] = (float64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                            D[k] = (float64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                            D[k] = (float64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                            D[k] = (float64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= 2*crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    case FVAL:
      { float64 *buffer = (float64 *) Get_AOA_Buffer();
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume/2;
            else
              crea = AOA_BUFLEN/2;

            j = load_buffer_fval(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr * er);
                            D[k] = (uint8) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr * er);
                            D[k] = (uint8) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr / er);
                            D[k] = (uint8) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint8) (dr / er);
                            D[k] = (uint8) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] << er);
                            D[k] = (uint8) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] << er);
                            D[k] = (uint8) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] >> er);
                            D[k] = (uint8) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint8) (d[k] >> er);
                            D[k] = (uint8) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint8 dr = (uint8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr * er);
                            D[k] = (uint16) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr * er);
                            D[k] = (uint16) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr / er);
                            D[k] = (uint16) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint16) (dr / er);
                            D[k] = (uint16) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] << er);
                            D[k] = (uint16) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] << er);
                            D[k] = (uint16) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] >> er);
                            D[k] = (uint16) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint16) (d[k] >> er);
                            D[k] = (uint16) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint16 dr = (uint16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr * er);
                            D[k] = (uint32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr * er);
                            D[k] = (uint32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr / er);
                            D[k] = (uint32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint32) (dr / er);
                            D[k] = (uint32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] << er);
                            D[k] = (uint32) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] << er);
                            D[k] = (uint32) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] >> er);
                            D[k] = (uint32) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint32) (d[k] >> er);
                            D[k] = (uint32) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint32 dr = (uint32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (uint64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (uint64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr * er);
                            D[k] = (uint64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr * er);
                            D[k] = (uint64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr / er);
                            D[k] = (uint64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (uint64) (dr / er);
                            D[k] = (uint64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] << er);
                            D[k] = (uint64) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] << er);
                            D[k] = (uint64) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] >> er);
                            D[k] = (uint64) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (uint64) (d[k] >> er);
                            D[k] = (uint64) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { uint64 dr = (uint64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int8) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int8) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr * er);
                            D[k] = (int8) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr * er);
                            D[k] = (int8) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr / er);
                            D[k] = (int8) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int8) (dr / er);
                            D[k] = (int8) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] << er);
                            D[k] = (int8) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] << er);
                            D[k] = (int8) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] >> er);
                            D[k] = (int8) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int8) (d[k] >> er);
                            D[k] = (int8) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int8 dr = (int8) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int16) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int16) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr * er);
                            D[k] = (int16) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr * er);
                            D[k] = (int16) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr / er);
                            D[k] = (int16) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int16) (dr / er);
                            D[k] = (int16) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] << er);
                            D[k] = (int16) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] << er);
                            D[k] = (int16) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] >> er);
                            D[k] = (int16) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int16) (d[k] >> er);
                            D[k] = (int16) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int16 dr = (int16) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr * er);
                            D[k] = (int32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr * er);
                            D[k] = (int32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr / er);
                            D[k] = (int32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int32) (dr / er);
                            D[k] = (int32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] << er);
                            D[k] = (int32) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] << er);
                            D[k] = (int32) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] >> er);
                            D[k] = (int32) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int32) (d[k] >> er);
                            D[k] = (int32) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int32 dr = (int32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (int64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (int64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr * er);
                            D[k] = (int64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr * er);
                            D[k] = (int64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr / er);
                            D[k] = (int64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (int64) (dr / er);
                            D[k] = (int64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] << er);
                            D[k] = (int64) (D[k] << er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] << er);
                            D[k] = (int64) (D[k] << er);
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] >> er);
                            D[k] = (int64) (D[k] >> er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int er = (int) buffer[i];
                            d[k] = (int64) (d[k] >> er);
                            D[k] = (int64) (D[k] >> er);
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { int64 dr = (int64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (float32) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (float32) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                            D[k] = (float32) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr * er);
                            D[k] = (float32) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                            D[k] = (float32) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float32) (dr / er);
                            D[k] = (float32) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float32 dr = (float32) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            d[k] = D[k] = (float64) buffer[i];
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            d[k] = D[k] = (float64) buffer[i];
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + er);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - er);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                            D[k] = (float64) (di * er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr * er);
                            D[k] = (float64) (di * er);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                            D[k] = (float64) (di / er);
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            d[k] = (float64) (dr / er);
                            D[k] = (float64) (di / er);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) buffer[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr  = pow(mag,.5*er);
                            agr  = er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                            ;
                      else
                        for (i = 0; i < crea; i++, k += 2)
                            ;
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > dr) D[k] = dr;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i++, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      else
                        for (i = 0; i < crea; i++, k += 2)
                          { float64 dr = (float64) buffer[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < dr) D[k] = dr;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= 2*crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    }

  return (o);
}

APart *Complex_Op_Complex(APart *R(M(o)), Operator op, AForm *q)
{ Array *a = AForm_Array(o);
  Array *b = AForm_Array(q);
  AForm *m = o;

  boolean     alice;
  Size_Type   brea, crea;
  Indx_Type   i, j, k;
  Size_Type   volume;
  int         btype;
  double      mag, ang;
  double      mgr, agr;

  if (AForm_Kind(o) != COMPLEX_KIND || AForm_Kind(q) != COMPLEX_KIND)
    { fprintf(stderr,"Array forms must be complex (Complex_Op_Complex)\n");
      exit (1);
    }
  if ((op == LSH_OP || op == RSH_OP) && a->type >= FLOAT32_TYPE)
    { fprintf(stderr,"Shifting floating point values is not permitted (Array_Op_Array)\n");
      exit (1);
    }
  if (Is_Frame(m))
    { fprintf(stderr,"Complex_Op_Complex does not accept a frame as it first argument\n");
      exit (1);
    }

  if (b->type <= UINT64_TYPE)
    btype = UVAL;
  else if (b->type <= INT64_TYPE)
    btype = IVAL;
  else
    btype = FVAL;

  if (Is_Slice(q))
    j = Set_Slice_To_First(q);
  else
    j = 0;

  alice = Is_Slice(m);
  if (alice)
    k = Set_Slice_To_First(m);
  else
    k = 0;

  volume = AForm_Size(m);
  brea   = AForm_Size(q);

  switch (btype) {
    case UVAL:
      { uint64 *buffer = (uint64 *) Get_AOA_Buffer();
        uint64 *c = buffer;
        uint64 *C = c+1;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;

            j = load_buffer_uval(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) c[i];
                            D[k] = (uint8) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) c[i];
                            D[k] = (uint8) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint8) (dr*er - di*ei);
                            D[k] = (uint8) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint8) (dr*er - di*ei);
                            D[k] = (uint8) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            uint64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint8) ((dr*er + di*ei) / em);
                            D[k] = (uint8) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            uint64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint8) ((dr*er + di*ei) / em);
                            D[k] = (uint8) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) (d[k] << ((int) c[i]));
                            D[k] = (uint8) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) (d[k] << ((int) c[i]));
                            D[k] = (uint8) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) (d[k] >> ((int) c[i]));
                            D[k] = (uint8) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) (d[k] >> ((int) c[i]));
                            D[k] = (uint8) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) c[i];
                            D[k] = (uint16) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) c[i];
                            D[k] = (uint16) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint16) (dr*er - di*ei);
                            D[k] = (uint16) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint16) (dr*er - di*ei);
                            D[k] = (uint16) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            uint64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint16) ((dr*er + di*ei) / em);
                            D[k] = (uint16) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            uint64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint16) ((dr*er + di*ei) / em);
                            D[k] = (uint16) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) (d[k] << ((int) c[i]));
                            D[k] = (uint16) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) (d[k] << ((int) c[i]));
                            D[k] = (uint16) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) (d[k] >> ((int) c[i]));
                            D[k] = (uint16) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) (d[k] >> ((int) c[i]));
                            D[k] = (uint16) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) c[i];
                            D[k] = (uint32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) c[i];
                            D[k] = (uint32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint32) (dr*er - di*ei);
                            D[k] = (uint32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            d[k] = (uint32) (dr*er - di*ei);
                            D[k] = (uint32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            uint64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint32) ((dr*er + di*ei) / em);
                            D[k] = (uint32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            uint64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint32) ((dr*er + di*ei) / em);
                            D[k] = (uint32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) d[k];
                            uint64 di = (uint64) D[k];
                            uint64 er = (uint64) c[i];
                            uint64 ei = (uint64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) (d[k] << ((int) c[i]));
                            D[k] = (uint32) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) (d[k] << ((int) c[i]));
                            D[k] = (uint32) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) (d[k] >> ((int) c[i]));
                            D[k] = (uint32) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) (d[k] >> ((int) c[i]));
                            D[k] = (uint32) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) c[i];
                            D[k] = (uint64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) c[i];
                            D[k] = (uint64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr*er - di*ei);
                            D[k] = (uint64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr*er - di*ei);
                            D[k] = (uint64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint64) ((dr*er + di*ei) / em);
                            D[k] = (uint64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint64) ((dr*er + di*ei) / em);
                            D[k] = (uint64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) (d[k] << ((int) c[i]));
                            D[k] = (uint64) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) (d[k] << ((int) c[i]));
                            D[k] = (uint64) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) (d[k] >> ((int) c[i]));
                            D[k] = (uint64) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) (d[k] >> ((int) c[i]));
                            D[k] = (uint64) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) c[i];
                            D[k] = (int8) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) c[i];
                            D[k] = (int8) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr*er - di*ei);
                            D[k] = (int8) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr*er - di*ei);
                            D[k] = (int8) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int8) ((dr*er + di*ei) / em);
                            D[k] = (int8) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int8) ((dr*er + di*ei) / em);
                            D[k] = (int8) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) (d[k] << ((int) c[i]));
                            D[k] = (int8) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) (d[k] << ((int) c[i]));
                            D[k] = (int8) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) (d[k] >> ((int) c[i]));
                            D[k] = (int8) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) (d[k] >> ((int) c[i]));
                            D[k] = (int8) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) c[i];
                            D[k] = (int16) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) c[i];
                            D[k] = (int16) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr*er - di*ei);
                            D[k] = (int16) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr*er - di*ei);
                            D[k] = (int16) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int16) ((dr*er + di*ei) / em);
                            D[k] = (int16) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int16) ((dr*er + di*ei) / em);
                            D[k] = (int16) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) (d[k] << ((int) c[i]));
                            D[k] = (int16) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) (d[k] << ((int) c[i]));
                            D[k] = (int16) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) (d[k] >> ((int) c[i]));
                            D[k] = (int16) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) (d[k] >> ((int) c[i]));
                            D[k] = (int16) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) c[i];
                            D[k] = (int32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) c[i];
                            D[k] = (int32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr*er - di*ei);
                            D[k] = (int32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr*er - di*ei);
                            D[k] = (int32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int32) ((dr*er + di*ei) / em);
                            D[k] = (int32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int32) ((dr*er + di*ei) / em);
                            D[k] = (int32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) (d[k] << ((int) c[i]));
                            D[k] = (int32) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) (d[k] << ((int) c[i]));
                            D[k] = (int32) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) (d[k] >> ((int) c[i]));
                            D[k] = (int32) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) (d[k] >> ((int) c[i]));
                            D[k] = (int32) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) c[i];
                            D[k] = (int64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) c[i];
                            D[k] = (int64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr*er - di*ei);
                            D[k] = (int64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr*er - di*ei);
                            D[k] = (int64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int64) ((dr*er + di*ei) / em);
                            D[k] = (int64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int64) ((dr*er + di*ei) / em);
                            D[k] = (int64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) (d[k] << ((int) c[i]));
                            D[k] = (int64) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) (d[k] << ((int) c[i]));
                            D[k] = (int64) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) (d[k] >> ((int) c[i]));
                            D[k] = (int64) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) (d[k] >> ((int) c[i]));
                            D[k] = (int64) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (float32) c[i];
                            D[k] = (float32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (float32) c[i];
                            D[k] = (float32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr*er - di*ei);
                            D[k] = (float32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr*er - di*ei);
                            D[k] = (float32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float32) ((dr*er + di*ei) / em);
                            D[k] = (float32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float32) ((dr*er + di*ei) / em);
                            D[k] = (float32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (float64) c[i];
                            D[k] = (float64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (float64) c[i];
                            D[k] = (float64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr*er - di*ei);
                            D[k] = (float64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr*er - di*ei);
                            D[k] = (float64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float64) ((dr*er + di*ei) / em);
                            D[k] = (float64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float64) ((dr*er + di*ei) / em);
                            D[k] = (float64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    case IVAL:
      { int64 *buffer = (int64 *) Get_AOA_Buffer();
        int64 *c = buffer;
        int64 *C = c+1;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;

            j = load_buffer_ival(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) c[i];
                            D[k] = (uint8) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) c[i];
                            D[k] = (uint8) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint8) (dr*er - di*ei);
                            D[k] = (uint8) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint8) (dr*er - di*ei);
                            D[k] = (uint8) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint8) ((dr*er + di*ei) / em);
                            D[k] = (uint8) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint8) ((dr*er + di*ei) / em);
                            D[k] = (uint8) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) (d[k] << ((int) c[i]));
                            D[k] = (uint8) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) (d[k] << ((int) c[i]));
                            D[k] = (uint8) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) (d[k] >> ((int) c[i]));
                            D[k] = (uint8) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) (d[k] >> ((int) c[i]));
                            D[k] = (uint8) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) c[i];
                            D[k] = (uint16) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) c[i];
                            D[k] = (uint16) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint16) (dr*er - di*ei);
                            D[k] = (uint16) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint16) (dr*er - di*ei);
                            D[k] = (uint16) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint16) ((dr*er + di*ei) / em);
                            D[k] = (uint16) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint16) ((dr*er + di*ei) / em);
                            D[k] = (uint16) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) (d[k] << ((int) c[i]));
                            D[k] = (uint16) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) (d[k] << ((int) c[i]));
                            D[k] = (uint16) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) (d[k] >> ((int) c[i]));
                            D[k] = (uint16) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) (d[k] >> ((int) c[i]));
                            D[k] = (uint16) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) c[i];
                            D[k] = (uint32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) c[i];
                            D[k] = (uint32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint32) (dr*er - di*ei);
                            D[k] = (uint32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint32) (dr*er - di*ei);
                            D[k] = (uint32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint32) ((dr*er + di*ei) / em);
                            D[k] = (uint32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint32) ((dr*er + di*ei) / em);
                            D[k] = (uint32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) (d[k] << ((int) c[i]));
                            D[k] = (uint32) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) (d[k] << ((int) c[i]));
                            D[k] = (uint32) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) (d[k] >> ((int) c[i]));
                            D[k] = (uint32) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) (d[k] >> ((int) c[i]));
                            D[k] = (uint32) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) c[i];
                            D[k] = (uint64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) c[i];
                            D[k] = (uint64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr*er - di*ei);
                            D[k] = (uint64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (uint64) (dr*er - di*ei);
                            D[k] = (uint64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint64) ((dr*er + di*ei) / em);
                            D[k] = (uint64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint64) ((dr*er + di*ei) / em);
                            D[k] = (uint64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) (d[k] << ((int) c[i]));
                            D[k] = (uint64) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) (d[k] << ((int) c[i]));
                            D[k] = (uint64) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) (d[k] >> ((int) c[i]));
                            D[k] = (uint64) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) (d[k] >> ((int) c[i]));
                            D[k] = (uint64) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) c[i];
                            D[k] = (int8) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) c[i];
                            D[k] = (int8) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr*er - di*ei);
                            D[k] = (int8) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int8) (dr*er - di*ei);
                            D[k] = (int8) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int8) ((dr*er + di*ei) / em);
                            D[k] = (int8) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int8) ((dr*er + di*ei) / em);
                            D[k] = (int8) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) (d[k] << ((int) c[i]));
                            D[k] = (int8) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) (d[k] << ((int) c[i]));
                            D[k] = (int8) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) (d[k] >> ((int) c[i]));
                            D[k] = (int8) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) (d[k] >> ((int) c[i]));
                            D[k] = (int8) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) c[i];
                            D[k] = (int16) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) c[i];
                            D[k] = (int16) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr*er - di*ei);
                            D[k] = (int16) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int16) (dr*er - di*ei);
                            D[k] = (int16) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int16) ((dr*er + di*ei) / em);
                            D[k] = (int16) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int16) ((dr*er + di*ei) / em);
                            D[k] = (int16) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) (d[k] << ((int) c[i]));
                            D[k] = (int16) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) (d[k] << ((int) c[i]));
                            D[k] = (int16) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) (d[k] >> ((int) c[i]));
                            D[k] = (int16) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) (d[k] >> ((int) c[i]));
                            D[k] = (int16) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) c[i];
                            D[k] = (int32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) c[i];
                            D[k] = (int32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr*er - di*ei);
                            D[k] = (int32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int32) (dr*er - di*ei);
                            D[k] = (int32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int32) ((dr*er + di*ei) / em);
                            D[k] = (int32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int32) ((dr*er + di*ei) / em);
                            D[k] = (int32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) (d[k] << ((int) c[i]));
                            D[k] = (int32) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) (d[k] << ((int) c[i]));
                            D[k] = (int32) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) (d[k] >> ((int) c[i]));
                            D[k] = (int32) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) (d[k] >> ((int) c[i]));
                            D[k] = (int32) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) c[i];
                            D[k] = (int64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) c[i];
                            D[k] = (int64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr*er - di*ei);
                            D[k] = (int64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            d[k] = (int64) (dr*er - di*ei);
                            D[k] = (int64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int64) ((dr*er + di*ei) / em);
                            D[k] = (int64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            int64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int64) ((dr*er + di*ei) / em);
                            D[k] = (int64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) d[k];
                            int64 di = (int64) D[k];
                            int64 er = (int64) c[i];
                            int64 ei = (int64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) (d[k] << ((int) c[i]));
                            D[k] = (int64) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) (d[k] << ((int) c[i]));
                            D[k] = (int64) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) (d[k] >> ((int) c[i]));
                            D[k] = (int64) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) (d[k] >> ((int) c[i]));
                            D[k] = (int64) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (float32) c[i];
                            D[k] = (float32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (float32) c[i];
                            D[k] = (float32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr*er - di*ei);
                            D[k] = (float32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr*er - di*ei);
                            D[k] = (float32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float32) ((dr*er + di*ei) / em);
                            D[k] = (float32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float32) ((dr*er + di*ei) / em);
                            D[k] = (float32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (float64) c[i];
                            D[k] = (float64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (float64) c[i];
                            D[k] = (float64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr*er - di*ei);
                            D[k] = (float64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr*er - di*ei);
                            D[k] = (float64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float64) ((dr*er + di*ei) / em);
                            D[k] = (float64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float64) ((dr*er + di*ei) / em);
                            D[k] = (float64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    case FVAL:
      { float64 *buffer = (float64 *) Get_AOA_Buffer();
        float64 *c = buffer;
        float64 *C = c+1;
        while (volume != 0)
          { if (volume < AOA_BUFLEN)
              crea = volume;
            else
              crea = AOA_BUFLEN;

            j = load_buffer_fval(buffer,q,crea,j,brea);

            switch (a->type) {
              case UINT8_TYPE:
                { uint8 *d = AUINT8(a);
                  uint8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) c[i];
                            D[k] = (uint8) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) c[i];
                            D[k] = (uint8) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint8) (dr + er);
                            D[k] = (uint8) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint8) (dr - er);
                            D[k] = (uint8) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint8) (dr*er - di*ei);
                            D[k] = (uint8) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint8) (dr*er - di*ei);
                            D[k] = (uint8) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint8) ((dr*er + di*ei) / em);
                            D[k] = (uint8) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint8) ((dr*er + di*ei) / em);
                            D[k] = (uint8) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint8) (mgr * cos(agr));
                            D[k] = (uint8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) (d[k] << ((int) c[i]));
                            D[k] = (uint8) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) (d[k] << ((int) c[i]));
                            D[k] = (uint8) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint8) (d[k] >> ((int) c[i]));
                            D[k] = (uint8) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint8) (d[k] >> ((int) c[i]));
                            D[k] = (uint8) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint8 dr = (uint8) c[i];
                            uint8 di = (uint8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *d = AUINT16(a);
                  uint16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) c[i];
                            D[k] = (uint16) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) c[i];
                            D[k] = (uint16) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint16) (dr + er);
                            D[k] = (uint16) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint16) (dr - er);
                            D[k] = (uint16) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint16) (dr*er - di*ei);
                            D[k] = (uint16) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint16) (dr*er - di*ei);
                            D[k] = (uint16) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint16) ((dr*er + di*ei) / em);
                            D[k] = (uint16) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint16) ((dr*er + di*ei) / em);
                            D[k] = (uint16) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint16) (mgr * cos(agr));
                            D[k] = (uint16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) (d[k] << ((int) c[i]));
                            D[k] = (uint16) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) (d[k] << ((int) c[i]));
                            D[k] = (uint16) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint16) (d[k] >> ((int) c[i]));
                            D[k] = (uint16) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint16) (d[k] >> ((int) c[i]));
                            D[k] = (uint16) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint16 dr = (uint16) c[i];
                            uint16 di = (uint16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *d = AUINT32(a);
                  uint32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) c[i];
                            D[k] = (uint32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) c[i];
                            D[k] = (uint32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint32) (dr + er);
                            D[k] = (uint32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint32) (dr - er);
                            D[k] = (uint32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint32) (dr*er - di*ei);
                            D[k] = (uint32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint32) (dr*er - di*ei);
                            D[k] = (uint32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint32) ((dr*er + di*ei) / em);
                            D[k] = (uint32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint32) ((dr*er + di*ei) / em);
                            D[k] = (uint32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint32) (mgr * cos(agr));
                            D[k] = (uint32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) (d[k] << ((int) c[i]));
                            D[k] = (uint32) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) (d[k] << ((int) c[i]));
                            D[k] = (uint32) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint32) (d[k] >> ((int) c[i]));
                            D[k] = (uint32) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint32) (d[k] >> ((int) c[i]));
                            D[k] = (uint32) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint32 dr = (uint32) c[i];
                            uint32 di = (uint32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *d = AUINT64(a);
                  uint64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) c[i];
                            D[k] = (uint64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) c[i];
                            D[k] = (uint64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint64) (dr + er);
                            D[k] = (uint64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint64) (dr - er);
                            D[k] = (uint64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint64) (dr*er - di*ei);
                            D[k] = (uint64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (uint64) (dr*er - di*ei);
                            D[k] = (uint64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint64) ((dr*er + di*ei) / em);
                            D[k] = (uint64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (uint64) ((dr*er + di*ei) / em);
                            D[k] = (uint64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (uint64) (mgr * cos(agr));
                            D[k] = (uint64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) (d[k] << ((int) c[i]));
                            D[k] = (uint64) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) (d[k] << ((int) c[i]));
                            D[k] = (uint64) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (uint64) (d[k] >> ((int) c[i]));
                            D[k] = (uint64) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (uint64) (d[k] >> ((int) c[i]));
                            D[k] = (uint64) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { uint64 dr = (uint64) c[i];
                            uint64 di = (uint64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *d = AINT8(a);
                  int8 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) c[i];
                            D[k] = (int8) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) c[i];
                            D[k] = (int8) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int8) (dr + er);
                            D[k] = (int8) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int8) (dr - er);
                            D[k] = (int8) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int8) (dr*er - di*ei);
                            D[k] = (int8) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int8) (dr*er - di*ei);
                            D[k] = (int8) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int8) ((dr*er + di*ei) / em);
                            D[k] = (int8) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int8) ((dr*er + di*ei) / em);
                            D[k] = (int8) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int8) (mgr * cos(agr));
                            D[k] = (int8) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) (d[k] << ((int) c[i]));
                            D[k] = (int8) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) (d[k] << ((int) c[i]));
                            D[k] = (int8) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int8) (d[k] >> ((int) c[i]));
                            D[k] = (int8) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int8) (d[k] >> ((int) c[i]));
                            D[k] = (int8) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int8 dr = (int8) c[i];
                            int8 di = (int8) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *d = AINT16(a);
                  int16 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) c[i];
                            D[k] = (int16) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) c[i];
                            D[k] = (int16) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int16) (dr + er);
                            D[k] = (int16) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int16) (dr - er);
                            D[k] = (int16) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int16) (dr*er - di*ei);
                            D[k] = (int16) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int16) (dr*er - di*ei);
                            D[k] = (int16) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int16) ((dr*er + di*ei) / em);
                            D[k] = (int16) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int16) ((dr*er + di*ei) / em);
                            D[k] = (int16) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int16) (mgr * cos(agr));
                            D[k] = (int16) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) (d[k] << ((int) c[i]));
                            D[k] = (int16) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) (d[k] << ((int) c[i]));
                            D[k] = (int16) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int16) (d[k] >> ((int) c[i]));
                            D[k] = (int16) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int16) (d[k] >> ((int) c[i]));
                            D[k] = (int16) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int16 dr = (int16) c[i];
                            int16 di = (int16) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *d = AINT32(a);
                  int32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) c[i];
                            D[k] = (int32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) c[i];
                            D[k] = (int32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int32) (dr + er);
                            D[k] = (int32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int32) (dr - er);
                            D[k] = (int32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int32) (dr*er - di*ei);
                            D[k] = (int32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int32) (dr*er - di*ei);
                            D[k] = (int32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int32) ((dr*er + di*ei) / em);
                            D[k] = (int32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int32) ((dr*er + di*ei) / em);
                            D[k] = (int32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int32) (mgr * cos(agr));
                            D[k] = (int32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) (d[k] << ((int) c[i]));
                            D[k] = (int32) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) (d[k] << ((int) c[i]));
                            D[k] = (int32) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int32) (d[k] >> ((int) c[i]));
                            D[k] = (int32) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int32) (d[k] >> ((int) c[i]));
                            D[k] = (int32) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int32 dr = (int32) c[i];
                            int32 di = (int32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *d = AINT64(a);
                  int64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) c[i];
                            D[k] = (int64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) c[i];
                            D[k] = (int64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int64) (dr + er);
                            D[k] = (int64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int64) (dr - er);
                            D[k] = (int64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int64) (dr*er - di*ei);
                            D[k] = (int64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (int64) (dr*er - di*ei);
                            D[k] = (int64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int64) ((dr*er + di*ei) / em);
                            D[k] = (int64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (int64) ((dr*er + di*ei) / em);
                            D[k] = (int64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (int64) (mgr * cos(agr));
                            D[k] = (int64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) (d[k] << ((int) c[i]));
                            D[k] = (int64) (D[k] << ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) (d[k] << ((int) c[i]));
                            D[k] = (int64) (D[k] << ((int) C[i]));
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (int64) (d[k] >> ((int) c[i]));
                            D[k] = (int64) (D[k] >> ((int) C[i]));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (int64) (d[k] >> ((int) c[i]));
                            D[k] = (int64) (D[k] >> ((int) C[i]));
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { int64 dr = (int64) c[i];
                            int64 di = (int64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *d = AFLOAT32(a);
                  float32 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (float32) c[i];
                            D[k] = (float32) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (float32) c[i];
                            D[k] = (float32) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr + er);
                            D[k] = (float32) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr - er);
                            D[k] = (float32) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr*er - di*ei);
                            D[k] = (float32) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float32) (dr*er - di*ei);
                            D[k] = (float32) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float32) ((dr*er + di*ei) / em);
                            D[k] = (float32) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float32) ((dr*er + di*ei) / em);
                            D[k] = (float32) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float32) (mgr * cos(agr));
                            D[k] = (float32) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float32 dr = (float32) c[i];
                            float32 di = (float32) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *d = AFLOAT64(a);
                  float64 *D = d+1;
                  switch (op) {
                    case SET_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { d[k] = (float64) c[i];
                            D[k] = (float64) C[i];
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { d[k] = (float64) c[i];
                            D[k] = (float64) C[i];
                          }
                      break;
                    case ADD_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr + er);
                            D[k] = (float64) (di + ei);
                          }
                      break;
                    case SUB_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr - er);
                            D[k] = (float64) (di - ei);
                          }
                      break;
                    case MUL_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr*er - di*ei);
                            D[k] = (float64) (di*er + dr*ei);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            d[k] = (float64) (dr*er - di*ei);
                            D[k] = (float64) (di*er + dr*ei);
                          }
                      break;
                    case DIV_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float64) ((dr*er + di*ei) / em);
                            D[k] = (float64) ((di*er - dr*ei) / em);
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            float64 em;				
                            em   = er*er + ei*ei;
                            d[k] = (float64) ((dr*er + di*ei) / em);
                            D[k] = (float64) ((di*er - dr*ei) / em);
                          }
                      break;
                    case POW_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) d[k];
                            float64 di = (float64) D[k];
                            float64 er = (float64) c[i];
                            float64 ei = (float64) C[i];
                            mag  = (double) (di*di + dr*dr);
                            ang  = atan2((double) di,(double) dr);
                            mgr = pow(mag,.5*er) * exp((-ang)*ei);
                            agr = .5*ei*log(mag) + er*ang;
                            d[k] = (float64) (mgr * cos(agr));
                            D[k] = (float64) (mgr * sin(agr));
                          }
                      break;
                    case LSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case RSH_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { ;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { ;
                          }
                      break;
                    case MIN_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] > dr) d[k] = dr;
                            if (D[k] > di) D[k] = di;
                          }
                      break;
                    case MAX_OP:
                      if (alice)
                        for (i = 0; i < crea; i += 2, Next_Slice_Index(m), k = Next_Slice_Index(m))
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      else
                        for (i = 0; i < crea; i += 2, k += 2)
                          { float64 dr = (float64) c[i];
                            float64 di = (float64) C[i];
                            if (d[k] < dr) d[k] = dr;
                            if (D[k] < di) D[k] = di;
                          }
                      break;
                    }
                  break;
                }
              }
            volume -= crea;
          }
        Release_AOA_Buffer(buffer);
        break;
      }
    }

  return (o);
}

/****************************************************************************************
 *                                                                                      *
 *  APPLYING FUNCTIONS TO ARRAY ELEMENTS                                                *
 *                                                                                      *
 ****************************************************************************************/

APart *Array_Fct_Val(APart *R(M(o)), Value (*fct)(void *valp))
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = AForm_Array(o);

  if (Is_Frame(o))
    { fprintf(stderr,"Array_Fct_Val does not operate on frames\n");
      exit (1);
    }

  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (uint8) fct((void *) (d+i)).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (uint8) fct((void *) (d+i)).uval;
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (uint16) fct((void *) (d+i)).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (uint16) fct((void *) (d+i)).uval;
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (uint32) fct((void *) (d+i)).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (uint32) fct((void *) (d+i)).uval;
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (uint64) fct((void *) (d+i)).uval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (uint64) fct((void *) (d+i)).uval;
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (int8) fct((void *) (d+i)).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (int8) fct((void *) (d+i)).ival;
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (int16) fct((void *) (d+i)).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (int16) fct((void *) (d+i)).ival;
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (int32) fct((void *) (d+i)).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (int32) fct((void *) (d+i)).ival;
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (int64) fct((void *) (d+i)).ival;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (int64) fct((void *) (d+i)).ival;
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (float32) fct((void *) (d+i)).fval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (float32) fct((void *) (d+i)).fval;
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { d[i] = (float64) fct((void *) (d+i)).fval;
                  if (i == e) break;
                }
            }
          else
            for (i = 0; i < a->size; i++)
              d[i] = (float64) fct((void *) (d+i)).fval;
          break;
        }
  }

  return (o);
}

APart *Array_Fct_Idx(APart *R(M(o)), Value (*fct)(Coordinate *coord))
{ Indx_Type p, e;
  Slice    *s = (Slice *) o;
  Array    *a = (Array *) AForm_Array(o);

  if (Is_Frame(o))
    { fprintf(stderr,"Array_Fct_Idx does not operate on frames\n");
      exit (1);
    }

  if (!Is_Slice(o))
    s = Make_Slice(a,Idx2CoordA(a,0),Idx2CoordA(a,a->size-1));

  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (uint8) fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (uint16) fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (uint32) fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (uint64) fct(Slice_Coordinate(s)).uval;
              if (p == e) break;
            }
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (int8) fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (int16) fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (int32) fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (int64) fct(Slice_Coordinate(s)).ival;
              if (p == e) break;
            }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (float32) fct(Slice_Coordinate(s)).fval;
              if (p == e) break;
            }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          e = Set_Slice_To_Last(s); 
          for (p = Set_Slice_To_First(s); 1; p = Next_Slice_Index(s)) 
            { d[p] = (float64) fct(Slice_Coordinate(s)).fval;
              if (p == e) break;
            }
          break;
        }
  }

  if (s != o)
    Kill_Slice(s);

  return (o);
}

//  Threshold values less than cutoff to black, all others to white

APart *Threshold_Array(APart *R(M(o)), Value cutoff)
{ Indx_Type i, e;
  Slice    *s = (Slice *) o;
  Array    *a = AForm_Array(o);

  if (Is_Frame(o))
    { fprintf(stderr,"Threshold_Array does not operate on frames\n");
      exit (1);
    }

  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          uint8  x, c = (uint8) cutoff.uval;
          uint8  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          uint16  x, c = (uint16) cutoff.uval;
          uint16  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          uint32  x, c = (uint32) cutoff.uval;
          uint32  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          uint64  x, c = (uint64) cutoff.uval;
          uint64  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          int8  x, c = (int8) cutoff.ival;
          int8  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          int16  x, c = (int16) cutoff.ival;
          int16  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          int32  x, c = (int32) cutoff.ival;
          int32  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          int64  x, c = (int64) cutoff.ival;
          int64  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          float32  x, c = (float32) cutoff.fval;
          float32  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          float64  x, c = (float64) cutoff.fval;
          float64  zero = 0, one = 1;

          if (Is_Slice(s))
            { e = Set_Slice_To_Last(s); 
              for (i = Set_Slice_To_First(s); 1; i = Next_Slice_Index(s)) 
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                  if (i == e) break;
                }
            }
          else
            { for (i = 0; i < a->size; i++)
                { x = d[i];
                  if (x <= c)
                    d[i] = zero;
                  else
                    d[i] = one;
                }
            }
          break;
        }
  }

  return (o);
}


/****************************************************************************************
 *                                                                                      *
 *  CONVERT IMAGE TYPES                                                                 *
 *                                                                                      *
 ****************************************************************************************/

typedef struct
  { Value_Type type;
    int        scale;
    void      *data;
  } Domain;

typedef struct
  { int    tshift;
    double dscale;
  } Variable_Scale;

#define LIKE_2_LIKE  0   // conversion codes
#define CPLX_2_NORM  1
#define  RGB_2_NORM  2
#define RGBA_2_NORM  3
#define RGBA_2_RGB   4


static void translate_CPLX_2_NORM_UINT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint8 *s0 = (uint8 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_UINT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint16 *s0 = (uint16 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_UINT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint32 *s0 = (uint32 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_UINT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint64 *s0 = (uint64 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_INT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int8 *s0 = (int8 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_INT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int16 *s0 = (int16 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_INT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int32 *s0 = (int32 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_INT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int64 *s0 = (int64 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_FLOAT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float32 *s0 = (float32 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_CPLX_2_NORM_FLOAT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float64 *s0 = (float64 *) sdata;
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (uint64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int8) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int16) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (int64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float32) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    { double x,y;
                      x = (double) s0[q++];
                      y = (double) s0[q++];
                      t0[p] = (float64) (sqrt(x*x+y*y) * afactor);
                    }
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_UINT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint8 *s0 = (uint8 *) sdata;
  uint8 *s1 = s0 + size;        
  uint8 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_UINT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint16 *s0 = (uint16 *) sdata;
  uint16 *s1 = s0 + size;        
  uint16 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_UINT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint32 *s0 = (uint32 *) sdata;
  uint32 *s1 = s0 + size;        
  uint32 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_UINT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint64 *s0 = (uint64 *) sdata;
  uint64 *s1 = s0 + size;        
  uint64 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_INT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int8 *s0 = (int8 *) sdata;
  int8 *s1 = s0 + size;        
  int8 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_INT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int16 *s0 = (int16 *) sdata;
  int16 *s1 = s0 + size;        
  int16 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_INT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int32 *s0 = (int32 *) sdata;
  int32 *s1 = s0 + size;        
  int32 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_INT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int64 *s0 = (int64 *) sdata;
  int64 *s1 = s0 + size;        
  int64 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_FLOAT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float32 *s0 = (float32 *) sdata;
  float32 *s1 = s0 + size;        
  float32 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGB_2_NORM_FLOAT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float64 *s0 = (float64 *) sdata;
  float64 *s1 = s0 + size;        
  float64 *s2 = s1 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor + .5);                  
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) ((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * afactor);                       
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_UINT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint8 *s0 = (uint8 *) sdata;
  uint8 *s1 = s0 + size;        
  uint8 *s2 = s1 + size;        
  uint8 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_UINT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint16 *s0 = (uint16 *) sdata;
  uint16 *s1 = s0 + size;        
  uint16 *s2 = s1 + size;        
  uint16 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_UINT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint32 *s0 = (uint32 *) sdata;
  uint32 *s1 = s0 + size;        
  uint32 *s2 = s1 + size;        
  uint32 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_UINT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint64 *s0 = (uint64 *) sdata;
  uint64 *s1 = s0 + size;        
  uint64 *s2 = s1 + size;        
  uint64 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_INT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int8 *s0 = (int8 *) sdata;
  int8 *s1 = s0 + size;        
  int8 *s2 = s1 + size;        
  int8 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_INT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int16 *s0 = (int16 *) sdata;
  int16 *s1 = s0 + size;        
  int16 *s2 = s1 + size;        
  int16 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_INT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int32 *s0 = (int32 *) sdata;
  int32 *s1 = s0 + size;        
  int32 *s2 = s1 + size;        
  int32 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_INT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int64 *s0 = (int64 *) sdata;
  int64 *s1 = s0 + size;        
  int64 *s2 = s1 + size;        
  int64 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_FLOAT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float32 *s0 = (float32 *) sdata;
  float32 *s1 = s0 + size;        
  float32 *s2 = s1 + size;        
  float32 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_NORM_FLOAT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float64 *s0 = (float64 *) sdata;
  float64 *s1 = s0 + size;        
  float64 *s2 = s1 + size;        
  float64 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (uint64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int8) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int16) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (int64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])) + .5);       
                }
              }
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float32) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;

              { Indx_Type q;
                for (q = p = 0; p < size; p++) {
                    t0[p] = (float64) (((.30*s0[p] + .59*s1[p] + .11*s2[p])
                                  * (afactor * s3[p])));            
                }
              }
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_UINT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint8 *s0 = (uint8 *) sdata;
  uint8 *s1 = s0 + size;        
  uint8 *s2 = s1 + size;        
  uint8 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_UINT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint16 *s0 = (uint16 *) sdata;
  uint16 *s1 = s0 + size;        
  uint16 *s2 = s1 + size;        
  uint16 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_UINT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint32 *s0 = (uint32 *) sdata;
  uint32 *s1 = s0 + size;        
  uint32 *s2 = s1 + size;        
  uint32 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_UINT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  uint64 *s0 = (uint64 *) sdata;
  uint64 *s1 = s0 + size;        
  uint64 *s2 = s1 + size;        
  uint64 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_INT8(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int8 *s0 = (int8 *) sdata;
  int8 *s1 = s0 + size;        
  int8 *s2 = s1 + size;        
  int8 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_INT16(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int16 *s0 = (int16 *) sdata;
  int16 *s1 = s0 + size;        
  int16 *s2 = s1 + size;        
  int16 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_INT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int32 *s0 = (int32 *) sdata;
  int32 *s1 = s0 + size;        
  int32 *s2 = s1 + size;        
  int32 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_INT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  int64 *s0 = (int64 *) sdata;
  int64 *s1 = s0 + size;        
  int64 *s2 = s1 + size;        
  int64 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_FLOAT32(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float32 *s0 = (float32 *) sdata;
  float32 *s1 = s0 + size;        
  float32 *s2 = s1 + size;        
  float32 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}


static void translate_RGBA_2_RGB_FLOAT64(void *sdata, void *tdata, Size_Type size, int ctype, double afactor)    
{ Indx_Type p;

  float64 *s0 = (float64 *) sdata;
  float64 *s1 = s0 + size;        
  float64 *s2 = s1 + size;        
  float64 *s3 = s2 + size;        
  
  switch (ctype) {
      case UINT8_TYPE:
        { uint8 *t0  = (uint8 *) tdata;
          uint8 *t1  = t0 + size;       
          uint8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT16_TYPE:
        { uint16 *t0  = (uint16 *) tdata;
          uint16 *t1  = t0 + size;       
          uint16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT32_TYPE:
        { uint32 *t0  = (uint32 *) tdata;
          uint32 *t1  = t0 + size;       
          uint32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case UINT64_TYPE:
        { uint64 *t0  = (uint64 *) tdata;
          uint64 *t1  = t0 + size;       
          uint64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (uint64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (uint64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (uint64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT8_TYPE:
        { int8 *t0  = (int8 *) tdata;
          int8 *t1  = t0 + size;       
          int8 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int8) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int8) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int8) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT16_TYPE:
        { int16 *t0  = (int16 *) tdata;
          int16 *t1  = t0 + size;       
          int16 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int16) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int16) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int16) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT32_TYPE:
        { int32 *t0  = (int32 *) tdata;
          int32 *t1  = t0 + size;       
          int32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int32) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int32) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int32) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case INT64_TYPE:
        { int64 *t0  = (int64 *) tdata;
          int64 *t1  = t0 + size;       
          int64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (int64) (s0[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t1[p] = (int64) (s1[p] * (afactor * s3[p]) + .4999); 
            for (p = 0; p < size; p++)
             t2[p] = (int64) (s2[p] * (afactor * s3[p]) + .4999); 
          return;
        }
      case FLOAT32_TYPE:
        { float32 *t0  = (float32 *) tdata;
          float32 *t1  = t0 + size;       
          float32 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float32) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float32) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float32) (s2[p] * (afactor * s3[p]));         
          return;
        }
      case FLOAT64_TYPE:
        { float64 *t0  = (float64 *) tdata;
          float64 *t1  = t0 + size;       
          float64 *t2  = t1 + size;       

            for (p = 0; p < size; p++)
             t0[p] = (float64) (s0[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t1[p] = (float64) (s1[p] * (afactor * s3[p]));         
            for (p = 0; p < size; p++)
             t2[p] = (float64) (s2[p] * (afactor * s3[p]));         
          return;
        }
  }
  return;
}



static void translate_CPLX_2_NORM(void *sdata, void *tdata, Size_Type size,
                          Value_Type stype, int ctype, double afactor)
{ switch (stype) {
       case UINT8_TYPE:
         translate_CPLX_2_NORM_UINT8(sdata,tdata,size,ctype,afactor);
         return;
       case UINT16_TYPE:
         translate_CPLX_2_NORM_UINT16(sdata,tdata,size,ctype,afactor);
         return;
       case UINT32_TYPE:
         translate_CPLX_2_NORM_UINT32(sdata,tdata,size,ctype,afactor);
         return;
       case UINT64_TYPE:
         translate_CPLX_2_NORM_UINT64(sdata,tdata,size,ctype,afactor);
         return;
       case INT8_TYPE:
         translate_CPLX_2_NORM_INT8(sdata,tdata,size,ctype,afactor);
         return;
       case INT16_TYPE:
         translate_CPLX_2_NORM_INT16(sdata,tdata,size,ctype,afactor);
         return;
       case INT32_TYPE:
         translate_CPLX_2_NORM_INT32(sdata,tdata,size,ctype,afactor);
         return;
       case INT64_TYPE:
         translate_CPLX_2_NORM_INT64(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT32_TYPE:
         translate_CPLX_2_NORM_FLOAT32(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT64_TYPE:
         translate_CPLX_2_NORM_FLOAT64(sdata,tdata,size,ctype,afactor);
         return;
  }
  return;
}


static void translate_RGB_2_NORM(void *sdata, void *tdata, Size_Type size,
                          Value_Type stype, int ctype, double afactor)
{ switch (stype) {
       case UINT8_TYPE:
         translate_RGB_2_NORM_UINT8(sdata,tdata,size,ctype,afactor);
         return;
       case UINT16_TYPE:
         translate_RGB_2_NORM_UINT16(sdata,tdata,size,ctype,afactor);
         return;
       case UINT32_TYPE:
         translate_RGB_2_NORM_UINT32(sdata,tdata,size,ctype,afactor);
         return;
       case UINT64_TYPE:
         translate_RGB_2_NORM_UINT64(sdata,tdata,size,ctype,afactor);
         return;
       case INT8_TYPE:
         translate_RGB_2_NORM_INT8(sdata,tdata,size,ctype,afactor);
         return;
       case INT16_TYPE:
         translate_RGB_2_NORM_INT16(sdata,tdata,size,ctype,afactor);
         return;
       case INT32_TYPE:
         translate_RGB_2_NORM_INT32(sdata,tdata,size,ctype,afactor);
         return;
       case INT64_TYPE:
         translate_RGB_2_NORM_INT64(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT32_TYPE:
         translate_RGB_2_NORM_FLOAT32(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT64_TYPE:
         translate_RGB_2_NORM_FLOAT64(sdata,tdata,size,ctype,afactor);
         return;
  }
  return;
}


static void translate_RGBA_2_NORM(void *sdata, void *tdata, Size_Type size,
                          Value_Type stype, int ctype, double afactor)
{ switch (stype) {
       case UINT8_TYPE:
         translate_RGBA_2_NORM_UINT8(sdata,tdata,size,ctype,afactor);
         return;
       case UINT16_TYPE:
         translate_RGBA_2_NORM_UINT16(sdata,tdata,size,ctype,afactor);
         return;
       case UINT32_TYPE:
         translate_RGBA_2_NORM_UINT32(sdata,tdata,size,ctype,afactor);
         return;
       case UINT64_TYPE:
         translate_RGBA_2_NORM_UINT64(sdata,tdata,size,ctype,afactor);
         return;
       case INT8_TYPE:
         translate_RGBA_2_NORM_INT8(sdata,tdata,size,ctype,afactor);
         return;
       case INT16_TYPE:
         translate_RGBA_2_NORM_INT16(sdata,tdata,size,ctype,afactor);
         return;
       case INT32_TYPE:
         translate_RGBA_2_NORM_INT32(sdata,tdata,size,ctype,afactor);
         return;
       case INT64_TYPE:
         translate_RGBA_2_NORM_INT64(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT32_TYPE:
         translate_RGBA_2_NORM_FLOAT32(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT64_TYPE:
         translate_RGBA_2_NORM_FLOAT64(sdata,tdata,size,ctype,afactor);
         return;
  }
  return;
}


static void translate_RGBA_2_RGB(void *sdata, void *tdata, Size_Type size,
                          Value_Type stype, int ctype, double afactor)
{ switch (stype) {
       case UINT8_TYPE:
         translate_RGBA_2_RGB_UINT8(sdata,tdata,size,ctype,afactor);
         return;
       case UINT16_TYPE:
         translate_RGBA_2_RGB_UINT16(sdata,tdata,size,ctype,afactor);
         return;
       case UINT32_TYPE:
         translate_RGBA_2_RGB_UINT32(sdata,tdata,size,ctype,afactor);
         return;
       case UINT64_TYPE:
         translate_RGBA_2_RGB_UINT64(sdata,tdata,size,ctype,afactor);
         return;
       case INT8_TYPE:
         translate_RGBA_2_RGB_INT8(sdata,tdata,size,ctype,afactor);
         return;
       case INT16_TYPE:
         translate_RGBA_2_RGB_INT16(sdata,tdata,size,ctype,afactor);
         return;
       case INT32_TYPE:
         translate_RGBA_2_RGB_INT32(sdata,tdata,size,ctype,afactor);
         return;
       case INT64_TYPE:
         translate_RGBA_2_RGB_INT64(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT32_TYPE:
         translate_RGBA_2_RGB_FLOAT32(sdata,tdata,size,ctype,afactor);
         return;
       case FLOAT64_TYPE:
         translate_RGBA_2_RGB_FLOAT64(sdata,tdata,size,ctype,afactor);
         return;
  }
  return;
}


static void translate(int conversion, Size_Type size, Domain *source,
                      Domain *target, Variable_Scale *var)
{ Value_Type stype,  ttype;
  void      *sdata, *tdata;
  double     dscale;
  int        shift;

  stype  = source->type;
  sdata  = source->data;

  ttype  = target->type;
  tdata  = target->data;

  dscale = var->dscale;
  shift  = var->tshift;

  if (conversion)
    { int       ctype;
      double    afactor;

      if (type_size[stype] < type_size[ttype])
        ctype = stype;
      else
        ctype = ttype;

      afactor = 1.;
      if (conversion >= RGBA_2_NORM && stype < FLOAT32_TYPE)
        { uint64 base = (((uint64) 1) << (source->scale-1));
          afactor /= ((base-1) + base);
        }
      if (type_size[stype] >= type_size[ttype])
        { if (shift > 0)
            afactor /= (1 << shift);
          else if (shift < 0)
            afactor *= (1 << -shift);
          else
            afactor *= dscale;
        }

      switch (conversion) {
          case CPLX_2_NORM:
            translate_CPLX_2_NORM(sdata,tdata,size,stype,ctype,afactor);
            break;
          case RGB_2_NORM:
            translate_RGB_2_NORM(sdata,tdata,size,stype,ctype,afactor);
            break;
          case RGBA_2_NORM:
            translate_RGBA_2_NORM(sdata,tdata,size,stype,ctype,afactor);
            break;
          case RGBA_2_RGB:
            translate_RGBA_2_RGB(sdata,tdata,size,stype,ctype,afactor);
            break;
      }

      sdata = tdata;
      if (type_size[stype] >= type_size[ttype])
        stype = ttype;
      if (conversion == RGBA_2_RGB)
        size *= 3;
  }

  if (ttype != stype || sdata != tdata)
    { Indx_Type p;

      if (shift > 0 || dscale != 1.)
        switch (stype) {
            case UINT8_TYPE:
              { uint8 *s = (uint8 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case UINT16_TYPE:
              { uint16 *s = (uint16 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case UINT32_TYPE:
              { uint32 *s = (uint32 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case UINT64_TYPE:
              { uint64 *s = (uint64 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT8_TYPE:
              { int8 *s = (int8 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT16_TYPE:
              { int16 *s = (int16 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT32_TYPE:
              { int32 *s = (int32 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT64_TYPE:
              { int64 *s = (int64 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] >> shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] >> shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] >> shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint64) (s[p] >> shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] >> shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] >> shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] >> shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int64) (s[p] >> shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *s = (float32 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] * dscale);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] * dscale);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] * dscale);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] * dscale);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] * dscale);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] * dscale);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] * dscale);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *s = (float64 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] * dscale);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] * dscale);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] * dscale);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint64) (s[p] * dscale);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] * dscale);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] * dscale);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] * dscale);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int64) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
        }

      else if (shift < 0)
        switch (stype) {
            case UINT8_TYPE:
              { uint8 *s = (uint8 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case UINT16_TYPE:
              { uint16 *s = (uint16 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case UINT32_TYPE:
              { uint32 *s = (uint32 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case UINT64_TYPE:
              { uint64 *s = (uint64 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT8_TYPE:
              { int8 *s = (int8 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT16_TYPE:
              { int16 *s = (int16 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT32_TYPE:
              { int32 *s = (int32 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case INT64_TYPE:
              { int64 *s = (int64 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] << shift);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] << shift);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] << shift);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint64) (s[p] << shift);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] << shift);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] << shift);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] << shift);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int64) (s[p] << shift);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *s = (float32 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] * dscale);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] * dscale);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] * dscale);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (uint64) (s[p] * dscale);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] * dscale);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] * dscale);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] * dscale);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (int64) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )               
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *s = (float64 *) sdata;
                shift  = - shift;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint8) (s[p] * dscale);         
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint16) (s[p] * dscale);         
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint32) (s[p] * dscale);         
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (uint64) (s[p] * dscale);         
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int8) (s[p] * dscale);         
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int16) (s[p] * dscale);         
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int32) (s[p] * dscale);         
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (int64) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float32) (s[p] * dscale);         
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)              
                          t[p] = (float64) (s[p] * dscale);         
                        break;
                      }
                }
                break;
              }
        }

      else
        switch (stype) {
            case UINT8_TYPE:
              { uint8 *s = (uint8 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case UINT16_TYPE:
              { uint16 *s = (uint16 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case UINT32_TYPE:
              { uint32 *s = (uint32 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case UINT64_TYPE:
              { uint64 *s = (uint64 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case INT8_TYPE:
              { int8 *s = (int8 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case INT16_TYPE:
              { int16 *s = (int16 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case INT32_TYPE:
              { int32 *s = (int32 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case INT64_TYPE:
              { int64 *s = (int64 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case FLOAT32_TYPE:
              { float32 *s = (float32 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = size; p-- > 0; )                       
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
            case FLOAT64_TYPE:
              { float64 *s = (float64 *) sdata;
                switch (ttype) {
                    case UINT8_TYPE:
                      { uint8 *t  = (uint8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint8) s[p];
                        break;
                      }
                    case UINT16_TYPE:
                      { uint16 *t  = (uint16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint16) s[p];
                        break;
                      }
                    case UINT32_TYPE:
                      { uint32 *t  = (uint32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint32) s[p];
                        break;
                      }
                    case UINT64_TYPE:
                      { uint64 *t  = (uint64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (uint64) s[p];
                        break;
                      }
                    case INT8_TYPE:
                      { int8 *t  = (int8 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int8) s[p];
                        break;
                      }
                    case INT16_TYPE:
                      { int16 *t  = (int16 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int16) s[p];
                        break;
                      }
                    case INT32_TYPE:
                      { int32 *t  = (int32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int32) s[p];
                        break;
                      }
                    case INT64_TYPE:
                      { int64 *t  = (int64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (int64) s[p];
                        break;
                      }
                    case FLOAT32_TYPE:
                      { float32 *t  = (float32 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float32) s[p];
                        break;
                      }
                    case FLOAT64_TYPE:
                      { float64 *t  = (float64 *) tdata;
                        for (p = 0; p < size; p++)                      
                          t[p] = (float64) s[p];
                        break;
                      }
                }
                break;
              }
        }
    }
}

static void imaginary_fill(Size_Type size, Domain *target)
{ Indx_Type p, q;

  switch (target->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(target);
          q = size;
          for (p = 2*size; p-- > 0; )
            { d[p--] = 0;
              d[p]   = d[--q];
            }
          break;
        }
  }
}

static void alpha_fill(Size_Type size, Domain *target, Value alpha)
{ Indx_Type p;

  switch (target->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (uint8) alpha.uval;
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (uint16) alpha.uval;
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (uint32) alpha.uval;
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (uint64) alpha.uval;
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (int8) alpha.ival;
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (int16) alpha.ival;
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (int32) alpha.ival;
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (int64) alpha.ival;
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (float32) alpha.fval;
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(target) + 3*size;
          for (p = 0; p < size; p++)
            d[p] = (float64) alpha.fval;
          break;
        }
  }
}

static Array *convert_array(Array *sarray, Array_Kind tkind, Value_Type ttype, int scale,
                            Variable_Scale *var, int in_place)
{ Domain     source, target;
  Array     *tarray;

  string     estring;
  int        tdims;
  Size_Type  tels, pels;

  Array_Kind skind  = sarray->kind;
  Value_Type stype  = sarray->type;

  pels   = sarray->size / kind_size[skind];
  tdims  = (sarray->ndims + (tkind != PLAIN_KIND)) - (skind != PLAIN_KIND);
  tels   = pels * kind_size[tkind];

  if (in_place)
    { estring = "Convert_Array_Inplace";
      tarray  = sarray;
    }
  else
    { estring = "Convert_Array";
      tarray  = new_array(0,0,1,estring);
      tarray->tlen    = 0;
      tarray->text[0] = '\0';
    }

  if (stype < FLOAT32_TYPE && ttype < FLOAT32_TYPE)
    { if (var->tshift > bit_size[ttype])
        { fprintf(stderr,"Scale factor shift is larger than number of bits in type (%s)\n",estring);
          exit (1);
        }
    }
  else
    { if (fabs(var->dscale) < 1e-20)
        { fprintf(stderr,"Scale factor is nearly 0, i.e. < 1e-20 (%s)\n",estring);
          exit (1);
        }
    }

  allocate_array_data(tarray,tels*type_size[ttype],estring);
  allocate_array_dims(tarray,SIZEOF(Dimn_Type)*tdims,estring);

  source.type  = stype;
  source.data  = sarray->data;
  source.scale = sarray->scale;

  target.type  = ttype;
  target.data  = tarray->data;

  if (tkind == skind)
    translate(LIKE_2_LIKE,kind_size[tkind]*pels,&source,&target,var);
  else if (tkind == PLAIN_KIND || tkind == COMPLEX_KIND)
    { if (skind == RGB_KIND)
        translate(RGB_2_NORM,pels,&source,&target,var);
      else if (skind == RGBA_KIND)
        translate(RGBA_2_NORM,pels,&source,&target,var);
      else if (skind == COMPLEX_KIND)
        translate(CPLX_2_NORM,pels,&source,&target,var);
      else
        translate(LIKE_2_LIKE,kind_size[tkind]*pels,&source,&target,var);
      if (tkind == COMPLEX_KIND)
        imaginary_fill(pels,&target);
    }
  else //  tkind == RGB_KIND || tkind == RGBA_KIND
    { if (skind == COMPLEX_KIND)
        translate(CPLX_2_NORM,pels,&source,&target,var);
      else if (skind == RGBA_KIND)
        translate(RGBA_2_RGB,pels,&source,&target,var);
      else
        translate(LIKE_2_LIKE,sarray->size,&source,&target,var);
      if (skind == PLAIN_KIND || skind == COMPLEX_KIND)
        { uint64 block = (uint64) (type_size[ttype]*pels);
          memcpy(((char *) tarray->data) + block,tarray->data,(size_t) block);
          memcpy(((char *) tarray->data) + 2*block,tarray->data,(size_t) block);
        }
      if (tkind == RGBA_KIND)
        { if (ttype <= UINT64_TYPE)
            alpha_fill(pels,&target,VALU(0xFFFFFFFFull));
          else if (ttype <= INT64_TYPE)
            alpha_fill(pels,&target,VALI(0x7FFFFFFFll));
          else
            alpha_fill(pels,&target,VALF(1.));
        }
    }

  { int i, cs, ct, nd;

    cs = (skind == COMPLEX_KIND);
    ct = (tkind == COMPLEX_KIND);
    nd = tdims - (tkind != PLAIN_KIND);
    if (ct > cs)
      { for (i = nd-1; i >= 0; i--)
          tarray->dims[i+ct] = sarray->dims[i+cs];
      }
    else
      { for (i = 0; i < nd; i++)
          tarray->dims[i+ct] = sarray->dims[i+cs];
      }
    if (ct)
      tarray->dims[0] = 2;
    if (!ct && nd != tdims)
      tarray->dims[nd] = kind_size[tkind];
  }

  tarray->size  = tels;
  tarray->kind  = tkind;
  tarray->type  = ttype;
  tarray->ndims = tdims;
  tarray->scale = scale;

  return (tarray);
}

Array *Convert_Array_Inplace(Array *R(M(sarray)), Array_Kind tkind, Value_Type ttype,
                             int tscale, ...)
{ Variable_Scale var;
  va_list        ap;

  if (sarray->kind == tkind && sarray->type == ttype)
    return (sarray);

  var.dscale = 1.;
  var.tshift = 0;

  va_start(ap,tscale);
  if (sarray->type < FLOAT32_TYPE && ttype < FLOAT32_TYPE)
    var.tshift = va_arg(ap,int);
  else
    var.dscale = va_arg(ap,double);
  va_end(ap);

  return (convert_array(sarray,tkind,ttype,tscale,&var,1));
}

Array *G(Convert_Array)(Array *sarray, Array_Kind tkind, Value_Type ttype, int tscale, ...)
{ Variable_Scale var;
  va_list        ap;

  if (sarray->kind == tkind && sarray->type == ttype)
    return (Copy_Array(sarray));

  var.dscale = 1.;
  var.tshift = 0;

  va_start(ap,tscale);
  if (sarray->type < FLOAT32_TYPE && ttype < FLOAT32_TYPE)
    var.tshift = va_arg(ap,int);
  else
    var.dscale = va_arg(ap,double);
  va_end(ap);

  return (convert_array(sarray,tkind,ttype,tscale,&var,0));
}

boolean Image_Check(Array *array)
{ Indx_Type p;
  uint64    vmax;
  int64     smax;

  if (array->kind == COMPLEX_KIND)
    { fprintf(stderr,"Array cannot be COMPLEX (Image_Check)\n");
      return (1);
    }

  if (array->type <= UINT64_TYPE)
    { uint64 base = (((uint64) 1) << (array->scale-1));
      vmax = (base-1) + base;
      smax = 0;
    }
  else if (array->type <= INT64_TYPE)
    { vmax = 0;
      smax = (int64) ((((uint64) 1) << (array->scale-1)) - 1);
    }
  else
    { vmax = 0;
      smax = 0;
    }

  switch (array->type) {
      case UINT8_TYPE:
        { uint8 *v = AUINT8(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case UINT16_TYPE:
        { uint16 *v = AUINT16(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case UINT32_TYPE:
        { uint32 *v = AUINT32(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case UINT64_TYPE:
        { uint64 *v = AUINT64(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > vmax)
                  return (1);
              }
          break;
        }
      case INT8_TYPE:
        { int8 *v = AINT8(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > smax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case INT16_TYPE:
        { int16 *v = AINT16(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > smax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case INT32_TYPE:
        { int32 *v = AINT32(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > smax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case INT64_TYPE:
        { int64 *v = AINT64(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > smax)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *v = AFLOAT32(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > 1.)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *v = AFLOAT64(array);
          for (p = 0; p < array->size; p++)
              { if (v[p] > 1.)
                  return (1);
                if (v[p] < 0)
                  return (1);
              }
          break;
        }
  }

  return (0);
}

Array *convert_image(Array *array, Array_Kind kind, Value_Type type, int scale, int in_place)
{ Variable_Scale var;
  Array         *rez;
  int            atype;

  var.dscale = 1.;
  var.tshift = array->scale - scale;

  atype = array->type;
  if (type >= FLOAT32_TYPE)
    { if (atype <= UINT64_TYPE)
        { uint64 base = (((uint64) 1) << (array->scale-1));
          var.dscale = 1. / ((base-1) + base);
        }
      else if (atype <= INT64_TYPE)
        var.dscale = 1. / ((((uint64) 1) << (array->scale-1)) - 1);
    }
  else if (type >= INT8_TYPE)
    { if (atype >= FLOAT32_TYPE)
        var.dscale = (double) ((((uint64) 1) << (scale-1)) - 1);
      else if (atype <= UINT64_TYPE)
        var.tshift += 1;
    }
  else
    { if (atype >= FLOAT32_TYPE)
        { uint64 base = (((uint64) 1) << (scale-1));
          var.dscale = (double) ((base-1) + base);
        }
      else if (atype >= INT64_TYPE)
        var.tshift -= 1;
    }

  rez = convert_array(array,kind,type,scale,&var,in_place);

  return (rez);
}

Array *Convert_Image_Inplace(Array *R(M(array)), Array_Kind kind, Value_Type type, int scale)
{ return (convert_image(array,kind,type,scale,1)); }

Array *G(Convert_Image)(Array *array, Array_Kind kind, Value_Type type, int scale)
{ return (convert_image(array,kind,type,scale,0)); }

/****************************************************************************************
 *                                                                                      *
 *  ARRAY MULTIPLICATION                                                                *
 *                                                                                      *
 ****************************************************************************************/

Array *G(Array_Multiply)(Array *a, Array *b)
{ int       acmplx  = (a->kind == COMPLEX_KIND);
  int       bcmplx  = (b->kind == COMPLEX_KIND);

  Array    *prod;
  Size_Type b_off, a_off;

  { Dimn_Type *adims  = a->dims + acmplx;
    Dimn_Type *bdims  = b->dims + bcmplx;
    int        andims = a->ndims - acmplx;
    int        bndims = b->ndims - bcmplx;
    int        complex = (acmplx || bcmplx);

    if (a->dims[acmplx] != b->dims[b->ndims-1])
      { fprintf(stderr,"Corresponding inner product dimensions for array multiply don't match");
        fprintf(stderr," (Array Multiply)\n");
        exit (1);
      }

    if (a->type != b->type)
      { fprintf(stderr,"Arrays must be of the same type (Array_Multiply)\n");
        exit (1);
      }

    if (complex)
      { prod = make_start(COMPLEX_KIND,a->type,andims+bndims-1,"Array_Multiply");
        prod->dims[0] = 2;
      }
    else
      prod = make_start(PLAIN_KIND,a->type,andims+bndims-2,"Array_Multiply");

    { Dimn_Type *pdims;
      int        i;

      pdims = prod->dims + complex;
      for (i = 1; i < andims; i++)
        pdims[bndims+i-2] = adims[i];
      for (i = 0; i < bndims-1; i++)
        pdims[i] = bdims[i];
    }

    prod->size = array_size(prod);

    allocate_array_data(prod,array_dsize(prod),"Make_Array");

    b_off  = ((b->size / bdims[bndims-1]) >> bcmplx);
    a_off  = adims[0];
  }

  { Size_Type p_off;
    Indx_Type p, q, r, t, k;

    switch (acmplx*2 + bcmplx) {
        case 0:
          p_off = b_off;          
          switch (a->type) {
              case UINT8_TYPE:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr;

                  for (q = 0; q < p_off; q += 1)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            for (t = q, k = 0; k < a_off; k++, t += b_off)
                              sr += x[k] * y[t];
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
        case 1:
          p_off = (b_off << 1);   
          b_off = p_off;          
          switch (a->type) {
              case UINT8_TYPE:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr;
                  uint8 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr;
                  uint16 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr;
                  uint32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr;
                  uint64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr;
                  int8 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr;
                  int16 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr;
                  int32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr;
                  int64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr;
                  float32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr;
                  float64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k++, t += b_off)
                                { sr += x[k] * y[t];
                                  si += x[k] * y[t+1];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
        case 2:
          p_off = (b_off << 1);   
          a_off <<= 1;            
          switch (a->type) {
              case UINT8_TYPE:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr;
                  uint8 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr;
                  uint16 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr;
                  uint32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr;
                  uint64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr;
                  int8 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr;
                  int16 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr;
                  int32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr;
                  int64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr;
                  float32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr;
                  float64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = (q>>1); k < a_off; k += 2, t += b_off)
                                { sr += x[k]   * y[t];
                                  si += x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
        case 3:
          p_off = (b_off << 1);   
          b_off = p_off;          
          a_off <<= 1;            
          switch (a->type) {
              case UINT8_TYPE:
                { uint8 *z = AUINT8(prod);
                  uint8 *y = AUINT8(b);
                  uint8 *x, sr;
                  uint8 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *z = AUINT16(prod);
                  uint16 *y = AUINT16(b);
                  uint16 *x, sr;
                  uint16 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *z = AUINT32(prod);
                  uint32 *y = AUINT32(b);
                  uint32 *x, sr;
                  uint32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *z = AUINT64(prod);
                  uint64 *y = AUINT64(b);
                  uint64 *x, sr;
                  uint64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AUINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT8_TYPE:
                { int8 *z = AINT8(prod);
                  int8 *y = AINT8(b);
                  int8 *x, sr;
                  int8 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT8(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT16_TYPE:
                { int16 *z = AINT16(prod);
                  int16 *y = AINT16(b);
                  int16 *x, sr;
                  int16 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT16(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT32_TYPE:
                { int32 *z = AINT32(prod);
                  int32 *y = AINT32(b);
                  int32 *x, sr;
                  int32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case INT64_TYPE:
                { int64 *z = AINT64(prod);
                  int64 *y = AINT64(b);
                  int64 *x, sr;
                  int64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AINT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT32_TYPE:
                { float32 *z = AFLOAT32(prod);
                  float32 *y = AFLOAT32(b);
                  float32 *x, sr;
                  float32 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT32(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
              case FLOAT64_TYPE:
                { float64 *z = AFLOAT64(prod);
                  float64 *y = AFLOAT64(b);
                  float64 *x, sr;
                  float64 si;		

                  for (q = 0; q < p_off; q += 2)
                    { x = AFLOAT64(a);
                      r = q;
                      for (p = 0; p < a->size; p += a_off)
                        { sr = 0;
                            si = 0;
                              for (k = 0, t = q; k < a_off; k += 2, t += b_off)
                                { sr += x[k] * y[t]   - x[k+1] * y[t+1];
                                  si += x[k] * y[t+1] + x[k+1] * y[t];
                                }
                            z[r+1] = si;
                          z[r] = sr;
                          r += p_off;
                          x += a_off;
                        }
                    }
                  break;
                }
          }
          break;
    }
  }

  return (prod);
}

/****************************************************************************************
 *                                                                                      *
 *  COLOR OR OTHER ARRAY MAPPING                                                        *
 *                                                                                      *
 ****************************************************************************************/


Array *G(Apply_Map)(Array *image, Array *map)
{ Array     *rez;
  Size_Type  inner;

  inner = map->dims[0];

  if (map->ndims < 1)
    { fprintf(stderr,"Map should be at least 1 dimensional (Apply_Map)\n");
      exit (1);
    }
  if (image->type > UINT64_TYPE || image->kind != PLAIN_KIND)
    { fprintf(stderr,"image must have unsigned values and be a PLAIN array (Apply_Map)\n");
      exit (1);
    }
  if (( 1ll << image->scale) != inner)
    { fprintf(stderr,"map length doesn't match image scale (Apply_Map)\n");
      exit (1);
    }

  { int i, j;

    rez = make_start(PLAIN_KIND,map->type,image->ndims+map->ndims-1,"Apply_Map");
    rez->kind  = map->kind;
    rez->scale = map->scale;
    for (i = 0; i < image->ndims; i++)
      rez->dims[i] = image->dims[i];
    for (j = 1, i = image->ndims; i < rez->ndims; i++, j++)
      rez->dims[i] = map->dims[j];
    rez->size = array_size(rez);
    allocate_array_data(rez,array_dsize(rez),"Apply_Map");
    Set_Array_Text(rez,image->text);
  }

  { Indx_Type p, q;

    switch (map->type) {
        case UINT8_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  uint8 *m = AUINT8(map);
                  uint8 *t = AUINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case UINT16_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  uint16 *m = AUINT16(map);
                  uint16 *t = AUINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case UINT32_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  uint32 *m = AUINT32(map);
                  uint32 *t = AUINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case UINT64_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  uint64 *m = AUINT64(map);
                  uint64 *t = AUINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case INT8_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  int8 *m = AINT8(map);
                  int8 *t = AINT8(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case INT16_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  int16 *m = AINT16(map);
                  int16 *t = AINT16(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case INT32_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  int32 *m = AINT32(map);
                  int32 *t = AINT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case INT64_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  int64 *m = AINT64(map);
                  int64 *t = AINT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case FLOAT32_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  float32 *m = AFLOAT32(map);
                  float32 *t = AFLOAT32(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
        case FLOAT64_TYPE:
          switch (image->type) {
              case UINT8_TYPE:
                { uint8 *a = AUINT8(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT16_TYPE:
                { uint16 *a = AUINT16(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT32_TYPE:
                { uint32 *a = AUINT32(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              case UINT64_TYPE:
                { uint64 *a = AUINT64(image);
                  float64 *m = AFLOAT64(map);
                  float64 *t = AFLOAT64(rez);
                  for (q = 0; q < map->size; q += inner)
                    { for (p = 0; p < image->size; p++)
                        *t++ = m[a[p]];
                      m += inner;
                    }
                  break;
                }
              default:
                break;
          }
          break;
    }
  }

  return (rez);
}


/****************************************************************************************
 *                                                                                      *
 *  DOWN SAMPLE CODE                                                                    *
 *                                                                                      *
 ****************************************************************************************/

static void down_sample(AForm *source, void *target, Coordinate *F(voxel), Coordinate *F(basis))
{ Size_Type Sdinc[10], *dinc;
  Size_Type Stinc[10], *tinc;
  Dimn_Type Sdcnt[10], *dcnt;
  Dimn_Type Stcnt[10], *tcnt;

  Array     *src     = AForm_Array(source);
  int        isframe = Is_Frame(source);
  int        ndims   = src->ndims;
  Dimn_Type *tdims   = ADIMN(basis);
  Dimn_Type *vdims   = ADIMN(voxel);
  Size_Type  dsize;

  if (ndims > 10)
    { dinc = (Size_Type *) Guarded_Malloc((sizeof(Size_Type)+sizeof(Dimn_Type))*2*((size_t) ndims),
                                           "Down_Sample");
      tinc = dinc + ndims;
      dcnt = ((Dimn_Type *) tinc) + ndims;
      tcnt = dcnt + ndims;
    }
  else
    { dinc = Sdinc;
      tinc = Stinc;
      dcnt = Sdcnt;
      tcnt = Stcnt;
    }

  { Size_Type  offset, outer, partial;
    Dimn_Type *sdims;
    int        i;

    if (isframe)
      sdims = ADIMN(Frame_Shape(source));
    else
      sdims = src->dims;

    dcnt[0] = 0;
    tcnt[0] = 0;
    tinc[0] = vdims[0];
    partial = (tdims[0]-1) * vdims[0];
    dinc[0] = 1;
    offset  = vdims[0] - 1;
    outer   = sdims[0];
    dsize   = vdims[0];
    for (i = 1; i < ndims; i++)
      { dcnt[i] = 0;
        tcnt[i] = 0;
        tinc[i] = vdims[i] * outer - partial;
        partial += (tdims[i]-1) * vdims[i] * outer;
        dinc[i] = outer - offset;
        offset += (vdims[i]-1)*outer;
        outer  *= sdims[i];
        dsize  *= vdims[i];
      }
  }

  { Indx_Type  q, p, r;
    Dimn_Type  d0 = 0;
    Dimn_Type  c0 = vdims[0];
    int        offsetable;
    Offs_Type *off;
    int        i;

    if (Is_Slice(source))
      q = Coord2IdxA(src,Inc_Array(Slice_First(source)));
    else
      q = 0;
    offsetable = 0;
    if (isframe)
      { offsetable = Frame_Within_Array(source);
        if (offsetable)
          off = Frame_Offsets(source);
      }

    if ( ! isframe)        
      switch (src->type) {
          case UINT8_TYPE:
            { uint8 *d = AUINT8(src);                           
              uint8 *a = (uint8 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint8) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *d = AUINT16(src);                           
              uint16 *a = (uint16 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint16) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *d = AUINT32(src);                           
              uint32 *a = (uint32 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *d = AUINT64(src);                           
              uint64 *a = (uint64 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT8_TYPE:
            { int8 *d = AINT8(src);                           
              int8 *a = (int8 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int8) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT16_TYPE:
            { int16 *d = AINT16(src);                           
              int16 *a = (int16 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int16) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT32_TYPE:
            { int32 *d = AINT32(src);                           
              int32 *a = (int32 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT64_TYPE:
            { int64 *d = AINT64(src);                           
              int64 *a = (int64 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *d = AFLOAT32(src);                           
              float32 *a = (float32 *) target;
              double sum;
              double den = (double) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (float32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *d = AFLOAT64(src);                           
              float64 *a = (float64 *) target;
              double sum;
              double den = (double) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (float64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
        }
    else if (offsetable)   
      switch (src->type) {
          case UINT8_TYPE:
            { uint8 *d = AUINT8(src) + Frame_Index(source);     
              uint8 *a = (uint8 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint8) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *d = AUINT16(src) + Frame_Index(source);     
              uint16 *a = (uint16 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint16) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *d = AUINT32(src) + Frame_Index(source);     
              uint32 *a = (uint32 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *d = AUINT64(src) + Frame_Index(source);     
              uint64 *a = (uint64 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT8_TYPE:
            { int8 *d = AINT8(src) + Frame_Index(source);     
              int8 *a = (int8 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int8) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT16_TYPE:
            { int16 *d = AINT16(src) + Frame_Index(source);     
              int16 *a = (int16 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int16) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT32_TYPE:
            { int32 *d = AINT32(src) + Frame_Index(source);     
              int32 *a = (int32 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT64_TYPE:
            { int64 *d = AINT64(src) + Frame_Index(source);     
              int64 *a = (int64 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *d = AFLOAT32(src) + Frame_Index(source);     
              float32 *a = (float32 *) target;
              double sum;
              double den = (double) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (float32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *d = AFLOAT64(src) + Frame_Index(source);     
              float64 *a = (float64 *) target;
              double sum;
              double den = (double) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[off[p]];                   
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (float64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
        }
    else                   
      switch (src->type) {
          case UINT8_TYPE:
            { uint8 *d = (uint8 *) Frame_Values(source);        
              uint8 *a = (uint8 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint8) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *d = (uint16 *) Frame_Values(source);        
              uint16 *a = (uint16 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint16) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *d = (uint32 *) Frame_Values(source);        
              uint32 *a = (uint32 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *d = (uint64 *) Frame_Values(source);        
              uint64 *a = (uint64 *) target;
              uint64 sum;
              uint64 den = (uint64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (uint64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT8_TYPE:
            { int8 *d = (int8 *) Frame_Values(source);        
              int8 *a = (int8 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int8) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT16_TYPE:
            { int16 *d = (int16 *) Frame_Values(source);        
              int16 *a = (int16 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int16) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT32_TYPE:
            { int32 *d = (int32 *) Frame_Values(source);        
              int32 *a = (int32 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case INT64_TYPE:
            { int64 *d = (int64 *) Frame_Values(source);        
              int64 *a = (int64 *) target;
              int64 sum;
              int64 den = (int64) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (int64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *d = (float32 *) Frame_Values(source);        
              float32 *a = (float32 *) target;
              double sum;
              double den = (double) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (float32) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *d = (float64 *) Frame_Values(source);        
              float64 *a = (float64 *) target;
              double sum;
              double den = (double) dsize;
  
              r = 0;
              i = 0;
              while (i != ndims)
                { p   = q;
                  sum = 0;
                  while (i != ndims)
                    { sum += d[p];                        
                      if (++d0 < c0)
                        p += 1;
                      else
                        { d0 = 0;
                          for (i = 1; i < ndims; i++)
                            if (++dcnt[i] == vdims[i])
                              dcnt[i] = 0;
                            else
                              { p += dinc[i];
                                break;
                              }
                        }
                    }
            
                  a[r++] = (float64) (sum/den);
            
                  for (i = 0; i < ndims; i++)
                    if (++tcnt[i] == tdims[i])
                      tcnt[i] = 0;
                    else
                      { q += tinc[i];
                        break;
                      }
                }
              break;
            }
        }
  }

  if (ndims > 10)
    free(dinc);

  Free_Array(voxel);
  Free_Array(basis);
}
 
static void check_dsample_args(AForm *source, Coordinate *M(point), string routine)
{ Dimn_Type  *crd;
  int         i, ndims;
  Array      *a = AForm_Array(source);
 
  ndims = (int) point->size;
  if (a->ndims != ndims && (a->ndims != ndims+1 || AForm_Kind(source) == PLAIN_KIND))
    { fprintf(stderr,"Array form dimensionaliy and down sample vector don't match");
      fprintf(stderr," (%s)\n",routine);
      exit (1);
    }

  crd = ADIMN(point);
  for (i = 0; i < a->ndims; i++)
    if (crd[i] == 0)
      { fprintf(stderr,"Down sample vector has a 0-component (%s)\n",routine);
        exit (1);
      }

  if (ndims == a->ndims-1)
    { if (AForm_Kind(source) == COMPLEX_KIND)
        PrependCoord(point,1);
      else
        AppendCoord(1,point);
    }
}

Array *Down_Sample_Inplace(Array *R(M(source)), Coordinate *F(ipoint))
{ Coordinate *basis, *point;
  Dimn_Type  *dims, *crd;
  int         i;

  point = Copy_Array(ipoint);
  Free_Array(ipoint);

  check_dsample_args(source,point,"Down_Sample_Inplace");

  basis = AForm_Shape(source);
  dims  = ADIMN(basis);
  crd   = ADIMN(point);
  for (i = 0; i < source->ndims; i++)
    dims[i] /= crd[i];

  down_sample(source,source->data,point,Inc_Array(basis));

  source->size = 1;
  for (i = 0; i < source->ndims; i++)
    { source->dims[i] = dims[i];
      source->size   *= dims[i];
    }

  Free_Array(basis);
  
  return (source);
}
    

Array *G(Down_Sample)(AForm *source, Coordinate *F(ipoint))
{ Coordinate *basis, *point;
  Array      *target;
  Dimn_Type  *dims, *crd;
  int         i;
  Array      *a = AForm_Array(source);

  point = Copy_Array(ipoint);
  Free_Array(ipoint);
 
  check_dsample_args(source,point,"Down_Sample");

  basis = AForm_Shape(source);
  dims  = ADIMN(basis);
  crd   = ADIMN(point);
  for (i = 0; i < a->ndims; i++)
    dims[i] /= crd[i];

  target = Make_Array(PLAIN_KIND,a->type,a->ndims,dims);
  target->kind = a->kind;

  down_sample(source,target->data,point,basis);

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY CLIPPING CODE                                                                 *
 *                                                                                      *
 ****************************************************************************************/

void clip_array(Array *source, void *target, Coordinate *S(beg), Coordinate *S(end))
{ Slice    *slice;
  Indx_Type p, r, e;

  slice = Make_Slice(source,beg,end);

  switch (source->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(source);
          uint8 *a = (uint8 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(source);
          uint16 *a = (uint16 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(source);
          uint32 *a = (uint32 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(source);
          uint64 *a = (uint64 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(source);
          int8 *a = (int8 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(source);
          int16 *a = (int16 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(source);
          int32 *a = (int32 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(source);
          int64 *a = (int64 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(source);
          float32 *a = (float32 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(source);
          float64 *a = (float64 *) target;

          e = Set_Slice_To_Last(slice);
          r = 0;
          for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
            { a[r++] = d[p];
              if (p == e) break;
            }
          break;
        }
  }

  Kill_Slice(slice);
}

void clip_frame(Frame *frame, void *target, Coordinate *S(beg), Coordinate *S(end))
{ _Array       _bundle;
  Array_Bundle *bundle = &_bundle.array;
  Slice        *slice;
  Indx_Type     p, r, e;
  Array        *a = AForm_Array(frame);

  slice = Make_Slice(Inc_Array(Frame_Array(bundle,frame)),beg,end);

  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *d = AUINT8(a);
          uint8 *a = (uint8 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { uint8 *v = (uint8 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case UINT16_TYPE:
        { uint16 *d = AUINT16(a);
          uint16 *a = (uint16 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { uint16 *v = (uint16 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case UINT32_TYPE:
        { uint32 *d = AUINT32(a);
          uint32 *a = (uint32 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { uint32 *v = (uint32 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case UINT64_TYPE:
        { uint64 *d = AUINT64(a);
          uint64 *a = (uint64 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { uint64 *v = (uint64 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case INT8_TYPE:
        { int8 *d = AINT8(a);
          int8 *a = (int8 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { int8 *v = (int8 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case INT16_TYPE:
        { int16 *d = AINT16(a);
          int16 *a = (int16 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { int16 *v = (int16 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case INT32_TYPE:
        { int32 *d = AINT32(a);
          int32 *a = (int32 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { int32 *v = (int32 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case INT64_TYPE:
        { int64 *d = AINT64(a);
          int64 *a = (int64 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { int64 *v = (int64 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case FLOAT32_TYPE:
        { float32 *d = AFLOAT32(a);
          float32 *a = (float32 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { float32 *v = (float32 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
      case FLOAT64_TYPE:
        { float64 *d = AFLOAT64(a);
          float64 *a = (float64 *) target;

          if (Frame_Within_Array(frame))
            { Offs_Type *off = Frame_Offsets(frame);
              d += Frame_Index(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = d[off[p]];
                  if (p == e) break;
                }
            }
          else
            { float64 *v = (float64 *) Frame_Values(frame);
              e = Set_Slice_To_Last(slice);
              r = 0;
              for (p = Set_Slice_To_First(slice); 1; p = Next_Slice_Index(slice))
                { a[r++] = v[p];
                  if (p == e) break;
                }
            }
          break;
        }
  }

  Kill_Slice(slice);
}

void check_clip_args(AForm *source, Coordinate *beg, Coordinate *end, string routine)
{ Coordinate *basis = AForm_Shape(source);
  Dimn_Type  *dims  = ADIMN(basis);
  Dimn_Type  *bcrd  = ADIMN(beg);
  Dimn_Type  *ecrd  = ADIMN(end);
  int         ndims = (int) end->size;
  int         i;

  if (ndims != beg->size)
    { fprintf(stderr,"Coordinates are not of same dimensionality (%s)\n",routine);
      exit (1);
    }
  if (basis->size != ndims && (basis->size != ndims+1 || AForm_Kind(source) == PLAIN_KIND))
    { fprintf(stderr,"Source and coordinate dimensionality do not match (%s)\n",routine);
      exit (1);
    }
  
  if (ndims == basis->size-1 && AForm_Kind(source) == COMPLEX_KIND)
    dims += 1;
  for (i = 0; i < ndims; i++)
    { if (bcrd[i] > ecrd[i])
        { fprintf(stderr,"beg coordinate is not before end coordinate (%s)\n",routine);
          exit (1);
        }
      if (ecrd[i] >= dims[i])
        { fprintf(stderr,"end is not in basis of target array (%s)\n",routine);
          exit (1);
        }
    }

  Free_Array(basis);
}
 
Array *Clip_Array_Inplace(Array *R(M(source)), Coordinate *F(beg), Coordinate *F(end))
{ Coordinate *shape;
  Dimn_Type  *bcrd, *scrd, *dims, s;
  int         i, ndims;

  check_clip_args(source,beg,end,"Clip_Array_Inplace");

  ndims = (int) end->size;
  shape = Copy_Array(end);
  bcrd  = ADIMN(beg);
  scrd  = ADIMN(shape);
  for (i = 0; i < ndims; i++)
    scrd[i] -= (bcrd[i]-1);

  clip_array(source,source->data,Copy_Array(beg),Copy_Array(end));
  Free_Array(beg);
  Free_Array(end);

  dims = source->dims;
  if (source->ndims != ndims)
    { source->size = kind_size[source->kind];
      if (source->kind == COMPLEX_KIND)
        dims += 1;
    }
  else
    source->size = 1;
  for (i = 0; i < ndims; i++)
    { dims[i] = s = scrd[i];
      source->size *= s;
    }

  Free_Array(shape);

  return (source);
}
    

Array *G(Clip_Array)(AForm *source, Coordinate *F(beg), Coordinate *F(end))
{ Coordinate *shape;
  Dimn_Type  *bcrd, *scrd;
  Array      *target;
  int         ndims, i;
  boolean     islice;
  Array      *a = AForm_Array(source);

  check_clip_args(source,beg,end,"Clip_Array");

  ndims = (int) end->size;

  islice = Is_Slice(source);
  if (islice)
    { Coordinate *gpnt = Copy_Array(beg);
      Coordinate *hpnt = Copy_Array(end);
      Coordinate *fpnt = Slice_First(source);
      Dimn_Type  *gcrd = ADIMN(gpnt);
      Dimn_Type  *hcrd = ADIMN(hpnt);
      Dimn_Type  *fcrd = ADIMN(fpnt);

      if (ndims != fpnt->size && AForm_Kind(source) == COMPLEX_KIND)
        fcrd += 1;
      for (i = 0; i < ndims; i++)
        { gcrd[i] += fcrd[i];
          hcrd[i] += fcrd[i];
        }
    
      Free_Array(beg);
      Free_Array(end);
      beg = gpnt;
      end = hpnt;
    }

  shape = Copy_Array(end);
  bcrd  = ADIMN(beg);
  scrd  = ADIMN(shape);
  for (i = 0; i < ndims; i++)
    scrd[i] -= (bcrd[i]-1);

  if (a->ndims == ndims)
    { target = Make_Array_With_Shape(PLAIN_KIND,a->type,shape);
      target->kind = AForm_Kind(source);
    }
  else
    target = Make_Array_With_Shape(AForm_Kind(source),a->type,shape);

  if (Is_Frame(source))
    clip_frame(source,target->data,Copy_Array(beg),Copy_Array(end));
  else if (islice)
    clip_array(a,target->data,beg,end);
  else
    clip_array(a,target->data,Copy_Array(beg),Copy_Array(end));

  if (!islice)
    { Free_Array(beg);
      Free_Array(end);
    }

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  ARRAY EXPANDING CODE                                                                *
 *                                                                                      *
 ****************************************************************************************/

void expand_array(Array *target, AForm *source, Size_Type size,
                  Coordinate *S(beg), Coordinate *S(end))
{ Slice     *slice;
  Indx_Type  p, q, x;
  int        in;
  Array     *base = AForm_Array(source);

  slice = Make_Slice(target,beg,end);
  in    = Set_Slice_To_Index(slice,target->size-1);

  if (Is_Slice(source))
    { x = Slice_Index(source);
      q = Set_Slice_To_Last(source);
      switch (target->type) {
          case UINT8_TYPE:
            { uint8 *a = AUINT8(target);
              uint8 *d = AUINT8(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *a = AUINT16(target);
              uint16 *d = AUINT16(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *a = AUINT32(target);
              uint32 *d = AUINT32(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *a = AUINT64(target);
              uint64 *d = AUINT64(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT8_TYPE:
            { int8 *a = AINT8(target);
              int8 *d = AINT8(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT16_TYPE:
            { int16 *a = AINT16(target);
              int16 *d = AINT16(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT32_TYPE:
            { int32 *a = AINT32(target);
              int32 *d = AINT32(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT64_TYPE:
            { int64 *a = AINT64(target);
              int64 *d = AINT64(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *a = AFLOAT32(target);
              float32 *d = AFLOAT32(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *a = AFLOAT64(target);
              float64 *d = AFLOAT64(base);                           

              for (p = target->size; p-- > 0; )
                { if (in)
                    { a[p] = d[q];                           
                      q = Prev_Slice_Index(source);          
                    }                                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
      }
      Set_Slice_To_Index(source,x);                          
    }
  else if (Is_Frame(source))
   if (Frame_Within_Array(source))
    { Offs_Type *off = Frame_Offsets(source) + size;
      switch (target->type) {
          case UINT8_TYPE:
            { uint8 *a = AUINT8(target);
              uint8 *d = AUINT8(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *a = AUINT16(target);
              uint16 *d = AUINT16(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *a = AUINT32(target);
              uint32 *d = AUINT32(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *a = AUINT64(target);
              uint64 *d = AUINT64(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT8_TYPE:
            { int8 *a = AINT8(target);
              int8 *d = AINT8(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT16_TYPE:
            { int16 *a = AINT16(target);
              int16 *d = AINT16(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT32_TYPE:
            { int32 *a = AINT32(target);
              int32 *d = AINT32(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT64_TYPE:
            { int64 *a = AINT64(target);
              int64 *d = AINT64(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *a = AFLOAT32(target);
              float32 *d = AFLOAT32(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *a = AFLOAT64(target);
              float64 *d = AFLOAT64(base);                           

              d += Frame_Index(source);                      
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = d[*--off];                        
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
      }
    }
   else
    {
      switch (target->type) {
          case UINT8_TYPE:
            { uint8 *a = AUINT8(target);
              uint8 *d = (uint8 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *a = AUINT16(target);
              uint16 *d = (uint16 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *a = AUINT32(target);
              uint32 *d = (uint32 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *a = AUINT64(target);
              uint64 *d = (uint64 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT8_TYPE:
            { int8 *a = AINT8(target);
              int8 *d = (int8 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT16_TYPE:
            { int16 *a = AINT16(target);
              int16 *d = (int16 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT32_TYPE:
            { int32 *a = AINT32(target);
              int32 *d = (int32 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT64_TYPE:
            { int64 *a = AINT64(target);
              int64 *d = (int64 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *a = AFLOAT32(target);
              float32 *d = (float32 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *a = AFLOAT64(target);
              float64 *d = (float64 *) Frame_Values(source);         

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
      }
    }
  else
    {
      switch (target->type) {
          case UINT8_TYPE:
            { uint8 *a = AUINT8(target);
              uint8 *d = AUINT8(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT16_TYPE:
            { uint16 *a = AUINT16(target);
              uint16 *d = AUINT16(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT32_TYPE:
            { uint32 *a = AUINT32(target);
              uint32 *d = AUINT32(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case UINT64_TYPE:
            { uint64 *a = AUINT64(target);
              uint64 *d = AUINT64(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT8_TYPE:
            { int8 *a = AINT8(target);
              int8 *d = AINT8(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT16_TYPE:
            { int16 *a = AINT16(target);
              int16 *d = AINT16(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT32_TYPE:
            { int32 *a = AINT32(target);
              int32 *d = AINT32(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case INT64_TYPE:
            { int64 *a = AINT64(target);
              int64 *d = AINT64(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *a = AFLOAT32(target);
              float32 *d = AFLOAT32(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *a = AFLOAT64(target);
              float64 *d = AFLOAT64(base);                           

              d += size;                                     
              for (p = target->size; p-- > 0; )
                { if (in)
                    a[p] = *--d;                             
                  else
                    a[p] = 0;
                  in = Dec_Slice_Index(slice);
                }
              break;
            }
      }
    }

  if (Boundary_Case_8qm5 != BND_ZERO)
    { Coordinate *basis = AForm_Shape(source);
      int         ndims = target->ndims;
      Dimn_Type  *begc  = ADIMN(beg);
      Dimn_Type  *endc  = ADIMN(end);

      int64 Fbcrd[10], *bcrd;
      int64 Fecrd[10], *ecrd;
      int64 Fdvol[10], *dvol;

      Frame_Args args;

      if (ndims > 10)
        { bcrd = (int64 *) Guarded_Malloc(sizeof(int64)*3*((size_t) ndims),"Frame_Offsets");
          ecrd = bcrd + ndims;
          dvol = ecrd + ndims;
        }
      else
        { bcrd = Fbcrd;
          ecrd = Fecrd;
          dvol = Fdvol;
        }

      { int i;
        for (i = 0; i < ndims; i++)
          { bcrd[i] = - ((int64) begc[i]);
            ecrd[i] = target->dims[i] - ((int64) begc[i]);
          }
      }

      args.fbcrd = bcrd;
      args.fecrd = ecrd;
      args.fidim = target->dims;
      args.ffdim = ADIMN(basis);

      if (source == target)
        { int i;
          for (i = 0; i < ndims; i++)
            args.ffdim[i] = (endc[i] - begc[i]) + 1;
        }

      switch (target->type) {
          case UINT8_TYPE:
            { uint8 *a = AUINT8(target);
              uint8 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_uint8(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_uint8(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_uint8(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_uint8(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case UINT16_TYPE:
            { uint16 *a = AUINT16(target);
              uint16 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_uint16(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_uint16(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_uint16(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_uint16(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case UINT32_TYPE:
            { uint32 *a = AUINT32(target);
              uint32 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_uint32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_uint32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_uint32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_uint32(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case UINT64_TYPE:
            { uint64 *a = AUINT64(target);
              uint64 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_uint64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_uint64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_uint64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_uint64(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case INT8_TYPE:
            { int8 *a = AINT8(target);
              int8 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_int8(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_int8(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_int8(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_int8(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case INT16_TYPE:
            { int16 *a = AINT16(target);
              int16 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_int16(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_int16(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_int16(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_int16(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case INT32_TYPE:
            { int32 *a = AINT32(target);
              int32 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_int32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_int32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_int32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_int32(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case INT64_TYPE:
            { int64 *a = AINT64(target);
              int64 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_int64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_int64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_int64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_int64(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *a = AFLOAT32(target);
              float32 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_float32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_float32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_float32(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_float32(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *a = AFLOAT64(target);
              float64 *o = a;
              switch (Boundary_Case_8qm5)
              { case BND_REFLECT:
                  expand_reflect_float64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_WRAP:
                  expand_wrap_float64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_EXTEND:
                  expand_extend_float64(ndims-1,0,0,o,a,&args);
                  break;
                case BND_INVERT:
                  { int64 i, b;
                    b = 1;
                    for (i = 0; i < ndims; i++)
                      { b *= target->dims[i];
                        dvol[i] = b;
                      }
                    args.fdvol = dvol;
                    expand_invert_float64(ndims-1,0,0,0,o,a,&args);
                    break;
                  }
                default:
                  break;
              }
              break;
            }
      }

      if (ndims > 10)
        free(bcrd);
      Free_Array(basis);
    }

  Kill_Slice(slice);
}

void check_expand_args(AForm *source, Coordinate *anchor, Coordinate *shape, string routine)
{ Coordinate *basis = AForm_Shape(source);
  Dimn_Type  *dims  = ADIMN(basis);
  Dimn_Type  *acrd  = ADIMN(anchor);
  Dimn_Type  *scrd  = ADIMN(shape);
  int         ndims = (int) anchor->size;
  int         i;

  if (anchor->size != shape->size || basis->size != shape->size)
    { fprintf(stderr,"Coordinates are not of same dimensionality (%s)\n",routine);
      fprintf(stderr," (Pad_Array_Inplace)\n");
      exit (1);
    }
  if (basis->size != ndims && (basis->size != ndims+1 || AForm_Kind(source) == PLAIN_KIND))
    { fprintf(stderr,"Source and coordinate dimensionality do not match (%s)\n",routine);
      exit (1);
    }

  if (ndims == basis->size-1 && AForm_Kind(source) == COMPLEX_KIND)
    dims += 1;
  for (i = 0; i < ndims; i++)
    { if (acrd[i] >= scrd[i])
        { fprintf(stderr,"anchor coordinate is not inside shape (%s)\n",routine);
          exit (1);
        }
      if (acrd[i] + dims[i] > scrd[i])
        { fprintf(stderr,"source does not fit into shape when placed at anchor (%s)\n",routine);
          exit (1);
        }
    }

  Free_Array(basis);
}
 
Array *Pad_Array_Inplace(Array *R(M(source)), Coordinate *F(anchor), Coordinate *F(shape))
{ Coordinate *end;
  Dimn_Type  *ecrd, *acrd, *dims;
  Size_Type   size;
  int         i, ndims;

  check_expand_args(source,anchor,shape,"Pad_Array_Inplace");
  ndims = (int) anchor->size;

  end  = Copy_Array(shape);
  Free_Array(shape);

  size = source->size;
  ecrd = ADIMN(end);
  acrd = ADIMN(anchor);
  dims = source->dims;
  if (source->ndims != ndims)
    { source->size = kind_size[source->kind];
      if (source->kind == COMPLEX_KIND)
        dims += 1;
    }
  else
    source->size = 1;
  for (i = 0; i < ndims; i++)
    { int m = ecrd[i];
      ecrd[i] = acrd[i] + (dims[i]-1);
      dims[i] = m;
      source->size *= m;
    }

  allocate_array_data(source,array_dsize(source),"Expland_Array_In_Place");

  expand_array(source,source,size,Copy_Array(anchor),end);
  Free_Array(anchor);
  
  return (source);
}


Array *G(Pad_Array)(AForm *source, Coordinate *F(anchor), Coordinate *F(shape))
{ Array      *target;
  Coordinate *end, *basis;
  Dimn_Type  *ecrd, *acrd, *dims;
  int         i, ndims;
  Array      *a = AForm_Array(source);
 
  check_expand_args(source,anchor,shape,"Pad_Array");
  ndims = (int) anchor->size;

  end  = Copy_Array(shape);
  Free_Array(shape);

  ecrd = ADIMN(end);
  acrd = ADIMN(anchor);

  if (a->ndims == ndims)
    { target = Make_Array(PLAIN_KIND,a->type,a->ndims,ecrd);
      target->kind = AForm_Kind(source);
    }
  else
    target = Make_Array(AForm_Kind(source),a->type,ndims,ecrd);

  basis = AForm_Shape(source);
  dims  = ADIMN(basis);
  if (a->ndims != ndims && AForm_Kind(source) == COMPLEX_KIND)
    dims += 1;
  for (i = 0; i < ndims; i++)
    ecrd[i] = acrd[i] + (dims[i]-1);
  Free_Array(basis);

  expand_array(target,source,AForm_Size(source),Copy_Array(anchor),end);
  Free_Array(anchor);

  return (target);
}


/****************************************************************************************
 *                                                                                      *
 *  CORRELATION AND REGRESSION ROUTINES                                                 *
 *                                                                                      *
 ****************************************************************************************/

static double inner_product_arrays(AForm *o1, AForm *o2)
{ Array      *a2 = AForm_Array(o2);
  Value_Type  t1 = AForm_Array(o1)->type;

  Size_Type n, v;
  Indx_Type p, q, i;
  double    s;

  boolean    in2  = 0;
  Offs_Type *off2 = NULL;
  Indx_Type  ctr2 = 0;
  double    *buf;

  if (Is_Slice(o1))
    p = Set_Slice_To_First(o1);
  else
    p = 0;

  q = 0;
  if (Is_Frame(o2))
    { in2 = Frame_Within_Array(o2);
      if (in2)
        { off2 = Frame_Offsets(o2);
          ctr2 = Frame_Index(o2);
        }
    }
  else if (Is_Slice(o2))
    q = Set_Slice_To_First(o2);

  buf = Get_AOA_Buffer();

  n = AForm_Size(o1);
  s = 0;
  for (n = AForm_Size(o1); n > 0; n -= v)
    { if (n < AOA_BUFLEN)
        v = n;
      else
        v = AOA_BUFLEN;

      if (t1 <= UINT32_TYPE)
        { uint64 *ubuf = (uint64 *) buf;
          p = load_buffer_uval(ubuf,o1,v,p,n);
          for (i = 0; i < v; i++)
            buf[i] = (double) ubuf[i];
        }
      else if (t1 <= INT32_TYPE)
        { int64 *ibuf = (int64 *) buf;
          p = load_buffer_ival(ibuf,o1,v,p,n);
          for (i = 0; i < v; i++)
            buf[i] = (double) ibuf[i];
        }
      else
        p = load_buffer_fval(buf,o1,v,p,n);

      switch (a2->type) {
          case UINT8_TYPE:
            { uint8 *d = AUINT8(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (uint8 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case UINT16_TYPE:
            { uint16 *d = AUINT16(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (uint16 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case UINT32_TYPE:
            { uint32 *d = AUINT32(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (uint32 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case UINT64_TYPE:
            { uint64 *d = AUINT64(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (uint64 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case INT8_TYPE:
            { int8 *d = AINT8(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (int8 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case INT16_TYPE:
            { int16 *d = AINT16(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (int16 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case INT32_TYPE:
            { int32 *d = AINT32(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (int32 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case INT64_TYPE:
            { int64 *d = AINT64(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (int64 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case FLOAT32_TYPE:
            { float32 *d = AFLOAT32(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (float32 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
          case FLOAT64_TYPE:
            { float64 *d = AFLOAT64(a2);
              switch (AForm_Class(o2))
              { case SLICE_CLASS:
                  for (i = 0; i < v; i++)
                    { s += buf[i] * d[q];
                      q = Next_Slice_Index(o2);
                    }
                  break;
                case FRAME_CLASS:
                  if (in2)
                    { d += ctr2;
                      for (i = 0; i < v; i++)
                        s += buf[i] * d[off2[q++]];
                      break;
                    }
                  else
                    d = (float64 *) Frame_Values(o2);
                case ARRAY_CLASS:
                  for (i = 0; i < v; i++)
                    s += buf[i] * d[q++];
                  break;
              }
              break;
            }
       }
    }

  Release_AOA_Buffer(buf);

  return (s);
}

static double sum_array(AForm *o)
{ Indx_Type p;
  double    t;

  Array    *a = AForm_Array(o);
  Size_Type n = AForm_Size(o);

  t = 0;
  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *v = AUINT8(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case UINT16_TYPE:
        { uint16 *v = AUINT16(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case UINT32_TYPE:
        { uint32 *v = AUINT32(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case UINT64_TYPE:
        { uint64 *v = AUINT64(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case INT8_TYPE:
        { int8 *v = AINT8(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case INT16_TYPE:
        { int16 *v = AINT16(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case INT32_TYPE:
        { int32 *v = AINT32(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case INT64_TYPE:
        { int64 *v = AINT64(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case FLOAT32_TYPE:
        { float32 *v = AFLOAT32(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
      case FLOAT64_TYPE:
        { float64 *v = AFLOAT64(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              for (p = Set_Slice_To_First(o); n-- > 0; p = Next_Slice_Index(o))
                t += v[p];
              break;
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    t += v[off[n]];
                  return (t);
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                t += v[n];
              break;
          }
        }
  }
  return (t);
}

static void accumulate_model(Double_Vector *M(model), double wgt, AForm *o)
{ Indx_Type p;
  double   *m = AFLOAT64(model);

  Array    *a = AForm_Array(o);
  Size_Type n = AForm_Size(o);

  switch (a->type) {
      case UINT8_TYPE:
        { uint8 *v = AUINT8(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case UINT16_TYPE:
        { uint16 *v = AUINT16(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case UINT32_TYPE:
        { uint32 *v = AUINT32(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case UINT64_TYPE:
        { uint64 *v = AUINT64(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case INT8_TYPE:
        { int8 *v = AINT8(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case INT16_TYPE:
        { int16 *v = AINT16(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case INT32_TYPE:
        { int32 *v = AINT32(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case INT64_TYPE:
        { int64 *v = AINT64(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case FLOAT32_TYPE:
        { float32 *v = AFLOAT32(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
      case FLOAT64_TYPE:
        { float64 *v = AFLOAT64(a);
          switch (AForm_Class(o))
          { case SLICE_CLASS:
              { Slice *s = (Slice *) o;
                for (p = Set_Slice_To_First(s); n-- > 0; p = Next_Slice_Index(s))
                  *m++ += wgt*v[p];
                return;
              }
            case FRAME_CLASS:
              if (Frame_Within_Array(o))
                { Offs_Type *off = Frame_Offsets(o);
                  v += Frame_Index(o);
                  while (n-- > 0)
                    *m++ += wgt*v[off[n]];
                  return;
                }
              else
                v = Frame_Values(o);
            case ARRAY_CLASS:
              while (n-- > 0)
                *m++ += wgt*v[n];
              return;
          }
        }
  }
}

static Double_Matrix *G(correlate)(int n, AForm *a1, va_list *ap, string routine)
{ AForm         *Sargs[20], **args;
  Double_Matrix *rez;

  if (n > 20)
    args = (AForm **) Guarded_Malloc(sizeof(AForm *)*((size_t) n),routine);
  else
    args = Sargs;

  { int i;

    if (n > 0)
      args[0] = a1;
    else
      { fprintf(stderr,"List of arrays is empty (%s)\n",routine);
        exit (1);
      }
    for (i = 1; i < n; i++)
      { args[i] = (AForm *) va_arg(*ap,AForm *);
        if (AForm_Size(args[i]) != AForm_Size(args[0]))
          { fprintf(stderr,"Arrays do not have the same number of elements (%s)\n",routine);
            exit (1);
          }
      }
  }

  rez = Make_Array_With_Shape(PLAIN_KIND,FLOAT64_TYPE,Coord2(n,n));
  
  { double *a = AFLOAT64(rez);
    int     i, j;

    for (i = 0; i < n; i++)
      for (j = 0; j <= i; j++)
        a[j*n+i] = a[i*n+j] = inner_product_arrays(args[i],args[j]);
  }

  if (n > 20)
    free(args);
  
  return (rez);
}

static Double_Vector *G(array_sums)(int n, AForm *a1, va_list *ap)
{ Double_Vector *rez;

  rez = Make_Array_With_Shape(PLAIN_KIND,FLOAT64_TYPE,Coord1(n));
  
  { double *a = AFLOAT64(rez);
    int     i;

    a[0] = sum_array(a1);
    for (i = 1; i < n; i++)
      a[i] = sum_array((AForm *) va_arg(*ap,AForm *));
  }
  
  return (rez);
}

double A_Correlation(AForm *a1, AForm *a2)
{ return (inner_product_arrays(a1,a2)); }

Double_Matrix *G(Correlations)(int n, AForm *a1, ...)
{ va_list        ap;
  Double_Matrix *rez;

  va_start(ap,a1);
  rez = correlate(n,a1,&ap,"Correlation");
  va_end(ap);
  return (rez);
}

double A_Covariance(AForm *a1, AForm *a2)
{ double prod = inner_product_arrays(a1,a2);
  double sum1  = sum_array(a1);
  double sum2  = sum_array(a2);
  return ((prod - sum1*sum2)/AForm_Size(a1));
}

Double_Matrix *G(Covariances)(int n, AForm *a1, ...)
{ va_list        ap;
  Double_Matrix *rez;
  Double_Vector *sum;

  va_start(ap,a1);
  rez = correlate(n,a1,&ap,"Covariance");
  va_end(ap);

  va_start(ap,a1);
  sum = array_sums(n,a1,&ap);
  va_end(ap);

  { double   *a = AFLOAT64(rez);
    double   *m = AFLOAT64(sum);
    double    mi, mj, s;
    int       i, j;
    Size_Type N = AForm_Size(a1);

    for (i = 0; i < n; i++)
      { mi = m[i]/N;
        for (j = 0; j <= i; j++)
          { s  = a[j*n+i];
            mj = m[j];
            a[j*n+i] = a[i*n+j] = (s - mj*mi)/N;
          }
      }
  }

  Free_Array(sum);
  
  return (rez);
}

double A_Pearson_Correlation(AForm *a1, AForm *a2)
{ double prod = inner_product_arrays(a1,a2);
  double sig1 = inner_product_arrays(a1,a1);
  double sig2 = inner_product_arrays(a2,a2);
  double sum1 = sum_array(a1);
  double sum2 = sum_array(a2);
  Size_Type N = AForm_Size(a1);

  sig1 -= sum1*(sum1/N);
  sig2 -= sum2*(sum2/N);
  return ((prod - sum1*(sum2/N))/sqrt(sig1*sig2));
}

Double_Matrix *G(Pearson_Correlations)(int n, AForm *a1, ...)
{ va_list        ap;
  Double_Matrix *rez;
  Double_Vector *sum;

  va_start(ap,a1);
  rez = correlate(n,a1,&ap,"Pearson_Correlation");
  va_end(ap);

  va_start(ap,a1);
  sum = array_sums(n,a1,&ap);
  va_end(ap);

  { double   *a = AFLOAT64(rez);
    double   *m = AFLOAT64(sum);
    double    mi, mj, s;
    int       i, j;
    Size_Type N = AForm_Size(a1);

    for (i = 0; i < n; i++)
      { mi = m[i]/N;
        for (j = 0; j <= i; j++)
          { s  = a[j*n+i];
            mj = m[j];
            a[j*n+i] = a[i*n+j] = (s - mj*mi)/N;
          }
      }

    for (i = n*n-1; i >= 0; i -= n+1)
      a[i] = sqrt(a[i]);

    for (i = 1; i < n; i++)
      { mi = a[i*n+i];
        for (j = 0; j < i; j++)
          a[j*n+i] = a[i*n+j] /= (mi * a[j*n+j]);
      }

    for (i = n*n-1; i >= 0; i -= n+1)
      a[i] = 1.;
  }

  Free_Array(sum);
  
  return (rez);
}

Double_Vector *Linear_Regression(int n, Regression_Bundle *O(stats), AForm *obs, AForm *in1, ...)
{ va_list        ap;
  Double_Matrix *cof;
  Double_Vector *tgt;
  LU_Factor     *lu;
  boolean        stable;
  
  if (AForm_Size(obs) != AForm_Size(in1))
    { fprintf(stderr,"Arrays do not have the same number of elements (Linear_Regression)\n");
      exit (1);
    }

  va_start(ap,in1);
  cof = correlate(n,in1,&ap,"Linear_Regression");
  va_end(ap);

  lu = LU_Decompose(cof,&stable);
  if ( ! stable)
    fprintf(stderr,"Warning: Coefficient array inversion was unstable (Linear_Regression)\n");

  tgt = Make_Array_With_Shape(PLAIN_KIND,FLOAT64_TYPE,Coord1(n));
  
  { double *a = AFLOAT64(tgt);
    int     i;

    va_start(ap,in1);
    a[0] = inner_product_arrays(in1,obs);
    for (i = 1; i < n; i++)
      a[i] = inner_product_arrays((AForm *) va_arg(ap,AForm *),obs);
    va_end(ap);
  }
  
  LU_Solve(tgt,lu);

  if (stats != NULL)
    { Size_Type      N  = AForm_Size(in1);
      double         o2 = inner_product_arrays(obs,obs);
      double         oa = sum_array(obs);
      float64       *t  = AFLOAT64(tgt);

      int            i, j;
      Array         *sval, *tval;
      Dimn_Type      dims[1];
      Double_Vector *model;

      dims[0] = (Dimn_Type) N;
      model = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
      Array_Op_Scalar(model,SET_OP,FVAL,VALF(0.));

      va_start(ap,in1);
      accumulate_model(model,t[0],in1);
      for (i = 1; i < n; i++)
        accumulate_model(model,t[i],(AForm *) va_arg(ap,AForm *));
      va_end(ap);

      { double m2 = inner_product_arrays(model,model);
        double ma = sum_array(model);

        stats->tss = o2 - oa*(oa/N);
        stats->mss = m2 - (2*ma-oa)*(oa/N);
      }

      accumulate_model(model,-1.,obs);

      stats->rss = inner_product_arrays(model,model);

      stats->R2  = 1. - stats->rss / stats->tss;
      stats->aR2 = 1. - ((N-1)*(1.-stats->R2))/(N-n);
      stats->ser = sqrt(stats->rss / (N-n));

      Free_Array(model);

      dims[0] = n;
      if ((sval = stats->std_err) == NULL)
        sval = stats->std_err = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
      else
        { if (sval->size < n)
            allocate_array_data(sval,SIZEOF(float64)*n,"Linear_Regression");
          sval->kind  = PLAIN_KIND;
          sval->type  = FLOAT64_TYPE;
          sval->scale = 64;
          sval->ndims = 1;
          sval->size  = n;
          sval->dims[0] = n;
        }
      if ((tval = stats->t_stat) == NULL)
        tval = stats->t_stat = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
      else
        { if (tval->size < n)
            allocate_array_data(tval,SIZEOF(float64)*n,"Linear_Regression");
          tval->kind  = PLAIN_KIND;
          tval->type  = FLOAT64_TYPE;
          tval->scale = 64;
          tval->ndims = 1;
          tval->size  = n;
          tval->dims[0] = n;
        }

      { float64 *se = AFLOAT64(sval);
        float64 *ts = AFLOAT64(tval);

        for (i = 0; i < n; i++)
          { for (j = 0; j < n; j++)
              ts[j] = 0.;
            ts[i] = 1.;
            LU_Solve(tval,lu);
            se[i] = stats->ser*sqrt(ts[i]);
          }
        for (i = 0; i < n; i++)
          ts[i] = t[i] / se[i];
       }
    }

  Free_LU_Factor(lu);

  return (tgt);
}

Double_Vector *Simple_Regression(Array *R(O(vector)), Regression_Bundle *O(stats),
                                 AForm *obs, AForm *inp)
{ double    cof00, cof10, cof11;
  double    trg0, trg1;
  double    d, *data;
  Dimn_Type dims[1];

  if (AForm_Size(obs) != AForm_Size(inp))
    { fprintf(stderr,"Arrays do not have the same number of elements (Simplest_Regression)\n");
      exit (1);
    }

  dims[0] = 2;
  if (vector == NULL)
    vector = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
  else
    { if (vector->size < 2)
        allocate_array_data(vector,sizeof(float64)*2,"Simple_Regression");
      vector->kind  = PLAIN_KIND;
      vector->type  = FLOAT64_TYPE;
      vector->scale = 64;
      vector->ndims = 1;
      vector->size  = 2;
      vector->dims[0] = 2;
    }
  data = AFLOAT64(vector);

  cof00 = inner_product_arrays(inp,inp);
  cof10 = sum_array(inp);
  cof11 = (double) AForm_Size(inp);

  trg0  = inner_product_arrays(obs,inp);
  trg1  = sum_array(obs);

  d = (cof11*cof00 - cof10*cof10);
  data[0] = (cof00*trg1 - cof10*trg0) / d;
  data[1] = (cof11*trg0 - cof10*trg1) / d;

  if (stats != NULL)
    { Size_Type      N  = AForm_Size(inp);
      double         o2 = inner_product_arrays(obs,obs);
      double         oa = sum_array(obs);

      Array         *sval, *tval;
      Double_Vector *model;

      dims[0] = (Dimn_Type) N;
      model = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
      Array_Op_Scalar(model,SET_OP,FVAL,VALF(data[0]));
      accumulate_model(model,data[1],inp);

      { double m2 = inner_product_arrays(model,model);
        double ma = sum_array(model);

        stats->tss = o2 - oa*(oa/N);
        stats->mss = m2 - (2*ma-oa)*(oa/N);
      }

      accumulate_model(model,-1.,obs);

      stats->rss = inner_product_arrays(model,model);

      stats->R2  = 1. - stats->rss / stats->tss;
      stats->aR2 = 1. - ((N-1)*(1.-stats->R2))/(N-2);
      stats->ser = sqrt(stats->rss / (N-2));

      Free_Array(model);

      dims[0] = 2;
      if ((sval = stats->std_err) == NULL)
        sval = stats->std_err = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
      else
        { if (sval->size < 2)
            allocate_array_data(sval,sizeof(float64)*2,"Simple_Regression");
          sval->kind  = PLAIN_KIND;
          sval->type  = FLOAT64_TYPE;
          sval->scale = 64;
          sval->ndims = 1;
          sval->size  = 2;
          sval->dims[0] = 2;
        }
      if ((tval = stats->t_stat) == NULL)
        tval = stats->t_stat = Make_Array(PLAIN_KIND,FLOAT64_TYPE,1,dims);
      else
        { if (tval->size < 2)
            allocate_array_data(tval,sizeof(float64)*2,"Simple_Regression");
          tval->kind  = PLAIN_KIND;
          tval->type  = FLOAT64_TYPE;
          tval->scale = 64;
          tval->ndims = 1;
          tval->size  = 2;
          tval->dims[0] = 2;
        }

      { float64 *se = AFLOAT64(sval);
        float64 *ts = AFLOAT64(tval);

        se[0] =  stats->ser * sqrt(cof00/d);
        se[1] =  stats->ser * sqrt(cof11/d);
        ts[0] =  data[0] / se[0];
        ts[1] =  data[1] / se[1];
      }
    }

  return (vector);
}
